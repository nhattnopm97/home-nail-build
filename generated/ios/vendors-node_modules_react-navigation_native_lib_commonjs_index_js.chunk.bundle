(self["webpackChunkminiApp"] = self["webpackChunkminiApp"] || []).push([["vendors-node_modules_react-navigation_native_lib_commonjs_index_js"], {
16391: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "BaseNavigationContainer", ({
    enumerable: true,
    get: function() {
        return BaseNavigationContainer;
    }
}));
var _interop_require_default = __webpack_require__(66705);
var _interop_require_wildcard = __webpack_require__(83610);
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _object_without_properties = __webpack_require__(86136);
var _to_consumable_array = __webpack_require__(92716);
var _routers = __webpack_require__(93675);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _uselatestcallback = /*#__PURE__*/ _interop_require_default._(__webpack_require__(694));
var _checkDuplicateRouteNames = __webpack_require__(70349);
var _checkSerializable = __webpack_require__(65697);
var _createNavigationContainerRef = __webpack_require__(52249);
var _DeprecatedNavigationInChildContext = __webpack_require__(71777);
var _EnsureSingleNavigator = __webpack_require__(25569);
var _findFocusedRoute = __webpack_require__(86363);
var _NavigationBuilderContext = __webpack_require__(4323);
var _NavigationContainerRefContext = __webpack_require__(82435);
var _NavigationIndependentTreeContext = __webpack_require__(19771);
var _NavigationStateContext = __webpack_require__(16558);
var _ThemeProvider = __webpack_require__(46830);
var _UnhandledActionContext = __webpack_require__(16497);
var _useChildListeners = __webpack_require__(68905);
var _useEventEmitter = __webpack_require__(15813);
var _useKeyedChildListeners = __webpack_require__(26112);
var _useNavigationIndependentTree = __webpack_require__(11476);
var _useOptionsGetters = __webpack_require__(50920);
var _useSyncState = __webpack_require__(89065);
var _jsxruntime = __webpack_require__(70095);
var serializableWarnings = (/* unused pure expression or super */ null && ([]));
var duplicateNameWarnings = (/* unused pure expression or super */ null && ([]));
/**
 * Remove `key` and `routeNames` from the state objects recursively to get partial state.
 *
 * @param state Initial state object.
 */ var getPartialState = (state)=>{
    if (state === undefined) {
        return;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var key = state.key, routeNames = state.routeNames, partialState = _object_without_properties._(state, [
        "key",
        "routeNames"
    ]);
    return _object_spread_props._(_object_spread._({}, partialState), {
        stale: true,
        routes: state.routes.map((route)=>{
            if (route.state === undefined) {
                return route;
            }
            return _object_spread_props._(_object_spread._({}, route), {
                state: getPartialState(route.state)
            });
        })
    });
};
var BaseNavigationContainer = /*#__PURE__*/ _react.forwardRef(function BaseNavigationContainer(ref, ref1) {
    var initialState = ref.initialState, onStateChange = ref.onStateChange, onReady = ref.onReady, onUnhandledAction = ref.onUnhandledAction, _ref_navigationInChildEnabled = ref.navigationInChildEnabled, navigationInChildEnabled = _ref_navigationInChildEnabled === void 0 ? false : _ref_navigationInChildEnabled, theme = ref.theme, children = ref.children;
    var parent = _react.useContext(_NavigationStateContext.NavigationStateContext);
    var independent = (0, _useNavigationIndependentTree.useNavigationIndependentTree)();
    if (!parent.isDefault && !independent) {
        throw new Error("Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, wrap the container in 'NavigationIndependentTree' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.");
    }
    var _useSyncState1 = (0, _useSyncState.useSyncState)(()=>getPartialState(initialState == null ? undefined : initialState)), state = _useSyncState1.state, getState = _useSyncState1.getState, setState = _useSyncState1.setState, scheduleUpdate = _useSyncState1.scheduleUpdate, flushUpdates = _useSyncState1.flushUpdates;
    var isFirstMountRef = _react.useRef(true);
    var navigatorKeyRef = _react.useRef(undefined);
    var getKey = _react.useCallback(()=>navigatorKeyRef.current, []);
    var setKey = _react.useCallback((key)=>{
        navigatorKeyRef.current = key;
    }, []);
    var _useChildListeners1 = (0, _useChildListeners.useChildListeners)(), listeners = _useChildListeners1.listeners, addListener = _useChildListeners1.addListener;
    var _useKeyedChildListeners1 = (0, _useKeyedChildListeners.useKeyedChildListeners)(), keyedListeners = _useKeyedChildListeners1.keyedListeners, addKeyedListener = _useKeyedChildListeners1.addKeyedListener;
    var dispatch = (0, _uselatestcallback.default)((action)=>{
        if (listeners.focus[0] == null) {
            console.error(_createNavigationContainerRef.NOT_INITIALIZED_ERROR);
        } else {
            listeners.focus[0]((navigation)=>navigation.dispatch(action));
        }
    });
    var canGoBack = (0, _uselatestcallback.default)(()=>{
        if (listeners.focus[0] == null) {
            return false;
        }
        var _listeners_focus_ = listeners.focus[0]((navigation)=>navigation.canGoBack()), result = _listeners_focus_.result, handled = _listeners_focus_.handled;
        if (handled) {
            return result;
        } else {
            return false;
        }
    });
    var resetRoot = (0, _uselatestcallback.default)((state)=>{
        var _keyedListeners_getState_root, _keyedListeners_getState;
        var target = (state === null || state === void 0 ? void 0 : state.key) ?? ((_keyedListeners_getState_root = (_keyedListeners_getState = keyedListeners.getState).root) === null || _keyedListeners_getState_root === void 0 ? void 0 : _keyedListeners_getState_root.call(_keyedListeners_getState).key);
        if (target == null) {
            console.error(_createNavigationContainerRef.NOT_INITIALIZED_ERROR);
        } else {
            listeners.focus[0]((navigation)=>navigation.dispatch(_object_spread_props._(_object_spread._({}, _routers.CommonActions.reset(state)), {
                    target
                })));
        }
    });
    var getRootState = (0, _uselatestcallback.default)(()=>{
        var _keyedListeners_getState_root, _keyedListeners_getState;
        return (_keyedListeners_getState_root = (_keyedListeners_getState = keyedListeners.getState).root) === null || _keyedListeners_getState_root === void 0 ? void 0 : _keyedListeners_getState_root.call(_keyedListeners_getState);
    });
    var getCurrentRoute = (0, _uselatestcallback.default)(()=>{
        var state = getRootState();
        if (state == null) {
            return undefined;
        }
        var route = (0, _findFocusedRoute.findFocusedRoute)(state);
        return route;
    });
    var isReady = (0, _uselatestcallback.default)(()=>listeners.focus[0] != null);
    var emitter = (0, _useEventEmitter.useEventEmitter)();
    var _useOptionsGetters1 = (0, _useOptionsGetters.useOptionsGetters)({}), addOptionsGetter = _useOptionsGetters1.addOptionsGetter, getCurrentOptions = _useOptionsGetters1.getCurrentOptions;
    var navigation = _react.useMemo(()=>_object_spread_props._(_object_spread._({}, Object.keys(_routers.CommonActions).reduce((acc, name)=>{
            var _CommonActions;
            acc[name] = (...args)=>// @ts-expect-error: this is ok
                dispatch((_CommonActions = _routers.CommonActions)[name].apply(_CommonActions, _to_consumable_array._(args)));
            return acc;
        }, {}), emitter.create('root')), {
            dispatch,
            resetRoot,
            isFocused: ()=>true,
            canGoBack,
            getParent: ()=>undefined,
            getState,
            getRootState,
            getCurrentRoute,
            getCurrentOptions,
            isReady,
            setOptions: ()=>{
                throw new Error('Cannot call setOptions outside a screen');
            }
        }), [
        canGoBack,
        dispatch,
        emitter,
        getCurrentOptions,
        getCurrentRoute,
        getRootState,
        getState,
        isReady,
        resetRoot
    ]);
    _react.useImperativeHandle(ref1, ()=>navigation, [
        navigation
    ]);
    var onDispatchAction = (0, _uselatestcallback.default)((action, noop)=>{
        emitter.emit({
            type: '__unsafe_action__',
            data: {
                action,
                noop,
                stack: stackRef.current
            }
        });
    });
    var lastEmittedOptionsRef = _react.useRef(undefined);
    var onOptionsChange = (0, _uselatestcallback.default)((options)=>{
        if (lastEmittedOptionsRef.current === options) {
            return;
        }
        lastEmittedOptionsRef.current = options;
        emitter.emit({
            type: 'options',
            data: {
                options
            }
        });
    });
    var stackRef = _react.useRef(undefined);
    var builderContext = _react.useMemo(()=>({
            addListener,
            addKeyedListener,
            onDispatchAction,
            onOptionsChange,
            scheduleUpdate,
            flushUpdates,
            stackRef
        }), [
        addListener,
        addKeyedListener,
        onDispatchAction,
        onOptionsChange,
        scheduleUpdate,
        flushUpdates
    ]);
    var isInitialRef = _react.useRef(true);
    var getIsInitial = _react.useCallback(()=>isInitialRef.current, []);
    var context = _react.useMemo(()=>({
            state,
            getState,
            setState,
            getKey,
            setKey,
            getIsInitial,
            addOptionsGetter
        }), [
        state,
        getState,
        setState,
        getKey,
        setKey,
        getIsInitial,
        addOptionsGetter
    ]);
    var onReadyRef = _react.useRef(onReady);
    var onStateChangeRef = _react.useRef(onStateChange);
    _react.useEffect(()=>{
        isInitialRef.current = false;
        onStateChangeRef.current = onStateChange;
        onReadyRef.current = onReady;
    });
    var onReadyCalledRef = _react.useRef(false);
    _react.useEffect(()=>{
        if (!onReadyCalledRef.current && isReady()) {
            var _onReadyRef_current;
            onReadyCalledRef.current = true;
            (_onReadyRef_current = onReadyRef.current) === null || _onReadyRef_current === void 0 ? void 0 : _onReadyRef_current.call(onReadyRef);
            emitter.emit({
                type: 'ready'
            });
        }
    }, [
        state,
        isReady,
        emitter
    ]);
    _react.useEffect(()=>{
        var hydratedState = getRootState();
        if (false) { var duplicateRouteNamesResult, i, reason, pointer, message, curr, params, prev, path, location, message1, serializableResult }
        emitter.emit({
            type: 'state',
            data: {
                state
            }
        });
        if (!isFirstMountRef.current && onStateChangeRef.current) {
            onStateChangeRef.current(hydratedState);
        }
        isFirstMountRef.current = false;
    }, [
        getRootState,
        emitter,
        state
    ]);
    var defaultOnUnhandledAction = (0, _uselatestcallback.default)((action)=>{
        if (true) {
            return;
        }
        var payload = action.payload;
        var message = `The action '${action.type}'${payload ? ` with payload ${JSON.stringify(action.payload)}` : ''} was not handled by any navigator.`;
        switch(action.type){
            case 'PRELOAD':
            case 'NAVIGATE':
            case 'PUSH':
            case 'REPLACE':
            case 'POP_TO':
            case 'JUMP_TO':
                if (payload === null || payload === void 0 ? void 0 : payload.name) {
                    message += `\n\nDo you have a screen named '${payload.name}'?\n\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.\n\nIf you're using conditional rendering, navigation will happen automatically and you shouldn't navigate manually, see.`;
                } else {
                    message += `\n\nYou need to pass the name of the screen to navigate to.\n\nSee https://reactnavigation.org/docs/navigation-actions for usage.`;
                }
                break;
            case 'GO_BACK':
            case 'POP':
            case 'POP_TO_TOP':
                message += `\n\nIs there any screen to go back to?`;
                break;
            case 'OPEN_DRAWER':
            case 'CLOSE_DRAWER':
            case 'TOGGLE_DRAWER':
                message += `\n\nIs your screen inside a Drawer navigator?`;
                break;
        }
        message += `\n\nThis is a development-only warning and won't be shown in production.`;
        console.error(message);
    });
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationIndependentTreeContext.NavigationIndependentTreeContext.Provider, {
        value: false,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationContainerRefContext.NavigationContainerRefContext.Provider, {
            value: navigation,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationBuilderContext.NavigationBuilderContext.Provider, {
                value: builderContext,
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationStateContext.NavigationStateContext.Provider, {
                    value: context,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnhandledActionContext.UnhandledActionContext.Provider, {
                        value: onUnhandledAction ?? defaultOnUnhandledAction,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_DeprecatedNavigationInChildContext.DeprecatedNavigationInChildContext.Provider, {
                            value: navigationInChildEnabled,
                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_EnsureSingleNavigator.EnsureSingleNavigator, {
                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_ThemeProvider.ThemeProvider, {
                                    value: theme,
                                    children: children
                                })
                            })
                        })
                    })
                })
            })
        })
    });
}); //# sourceMappingURL=BaseNavigationContainer.js.map


}),
91650: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "CurrentRenderContext", ({
    enumerable: true,
    get: function() {
        return CurrentRenderContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var CurrentRenderContext = /*#__PURE__*/ _react.createContext(undefined); //# sourceMappingURL=CurrentRenderContext.js.map


}),
71777: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "DeprecatedNavigationInChildContext", ({
    enumerable: true,
    get: function() {
        return DeprecatedNavigationInChildContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var DeprecatedNavigationInChildContext = /*#__PURE__*/ _react.createContext(false); //# sourceMappingURL=DeprecatedNavigationInChildContext.js.map


}),
25569: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get EnsureSingleNavigator () {
        return EnsureSingleNavigator;
    },
    get SingleNavigatorContext () {
        return SingleNavigatorContext;
    }
});
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _jsxruntime = __webpack_require__(70095);
var MULTIPLE_NAVIGATOR_ERROR = `Another navigator is already registered for this container. You likely have multiple navigators under a single "NavigationContainer" or "Screen". Make sure each navigator is under a separate "Screen" container. See https://reactnavigation.org/docs/nesting-navigators for a guide on nesting.`;
var SingleNavigatorContext = /*#__PURE__*/ _react.createContext(undefined);
function EnsureSingleNavigator(ref) {
    var children = ref.children;
    var navigatorKeyRef = _react.useRef(undefined);
    var value = _react.useMemo(()=>({
            register (key) {
                var currentKey = navigatorKeyRef.current;
                if (currentKey !== undefined && key !== currentKey) {
                    throw new Error(MULTIPLE_NAVIGATOR_ERROR);
                }
                navigatorKeyRef.current = key;
            },
            unregister (key) {
                var currentKey = navigatorKeyRef.current;
                if (key !== currentKey) {
                    return;
                }
                navigatorKeyRef.current = undefined;
            }
        }), []);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(SingleNavigatorContext.Provider, {
        value: value,
        children: children
    });
} //# sourceMappingURL=EnsureSingleNavigator.js.map


}),
44052: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "Group", ({
    enumerable: true,
    get: function() {
        return Group;
    }
}));
function Group(_) {
    /* istanbul ignore next */ return null;
} //# sourceMappingURL=Group.js.map


}),
4323: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NavigationBuilderContext", ({
    enumerable: true,
    get: function() {
        return NavigationBuilderContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var NavigationBuilderContext = /*#__PURE__*/ _react.createContext({
    onDispatchAction: ()=>undefined,
    onOptionsChange: ()=>undefined,
    scheduleUpdate: ()=>{
        throw new Error("Couldn't find a context for scheduling updates.");
    },
    flushUpdates: ()=>{
        throw new Error("Couldn't find a context for flushing updates.");
    }
}); //# sourceMappingURL=NavigationBuilderContext.js.map


}),
82435: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NavigationContainerRefContext", ({
    enumerable: true,
    get: function() {
        return NavigationContainerRefContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var NavigationContainerRefContext = /*#__PURE__*/ _react.createContext(undefined); //# sourceMappingURL=NavigationContainerRefContext.js.map


}),
10776: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NavigationContext", ({
    enumerable: true,
    get: function() {
        return NavigationContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var NavigationContext = /*#__PURE__*/ _react.createContext(undefined); //# sourceMappingURL=NavigationContext.js.map


}),
79646: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NavigationFocusedRouteStateContext", ({
    enumerable: true,
    get: function() {
        return NavigationFocusedRouteStateContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var NavigationFocusedRouteStateContext = /*#__PURE__*/ _react.createContext(undefined); //# sourceMappingURL=NavigationFocusedRouteStateContext.js.map


}),
92177: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NavigationHelpersContext", ({
    enumerable: true,
    get: function() {
        return NavigationHelpersContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var NavigationHelpersContext = /*#__PURE__*/ _react.createContext(undefined); //# sourceMappingURL=NavigationHelpersContext.js.map


}),
29592: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NavigationIndependentTree", ({
    enumerable: true,
    get: function() {
        return NavigationIndependentTree;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationContext = __webpack_require__(10776);
var _NavigationIndependentTreeContext = __webpack_require__(19771);
var _NavigationRouteContext = __webpack_require__(39928);
var _jsxruntime = __webpack_require__(70095);
function NavigationIndependentTree(ref) {
    var children = ref.children;
    return(/*#__PURE__*/ // We need to clear any existing contexts for nested independent container to work correctly
    (0, _jsxruntime.jsx)(_NavigationRouteContext.NavigationRouteContext.Provider, {
        value: undefined,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationContext.NavigationContext.Provider, {
            value: undefined,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationIndependentTreeContext.NavigationIndependentTreeContext.Provider, {
                value: true,
                children: children
            })
        })
    }));
} //# sourceMappingURL=NavigationIndependentTree.js.map


}),
19771: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NavigationIndependentTreeContext", ({
    enumerable: true,
    get: function() {
        return NavigationIndependentTreeContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var NavigationIndependentTreeContext = /*#__PURE__*/ _react.createContext(false); //# sourceMappingURL=NavigationIndependentTreeContext.js.map


}),
39928: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NavigationRouteContext", ({
    enumerable: true,
    get: function() {
        return NavigationRouteContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var NavigationRouteContext = /*#__PURE__*/ _react.createContext(undefined); //# sourceMappingURL=NavigationRouteContext.js.map


}),
16558: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NavigationStateContext", ({
    enumerable: true,
    get: function() {
        return NavigationStateContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var MISSING_CONTEXT_ERROR = "Couldn't find a navigation context. Have you wrapped your app with 'NavigationContainer'? See https://reactnavigation.org/docs/getting-started for setup instructions.";
var NavigationStateContext = /*#__PURE__*/ _react.createContext({
    isDefault: true,
    get getKey () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setKey () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get getState () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setState () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get getIsInitial () {
        throw new Error(MISSING_CONTEXT_ERROR);
    }
}); //# sourceMappingURL=NavigationStateContext.js.map


}),
43346: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "PreventRemoveContext", ({
    enumerable: true,
    get: function() {
        return PreventRemoveContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var PreventRemoveContext = /*#__PURE__*/ _react.createContext(undefined); //# sourceMappingURL=PreventRemoveContext.js.map


}),
62053: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "PreventRemoveProvider", ({
    enumerable: true,
    get: function() {
        return PreventRemoveProvider;
    }
}));
var _interop_require_default = __webpack_require__(66705);
var _interop_require_wildcard = __webpack_require__(83610);
var _sliced_to_array = __webpack_require__(78474);
var _to_consumable_array = __webpack_require__(92716);
var _nonsecure = __webpack_require__(71289);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _uselatestcallback = /*#__PURE__*/ _interop_require_default._(__webpack_require__(694));
var _NavigationHelpersContext = __webpack_require__(92177);
var _NavigationRouteContext = __webpack_require__(39928);
var _PreventRemoveContext = __webpack_require__(43346);
var _jsxruntime = __webpack_require__(70095);
/**
 * Util function to transform map of prevented routes to a simpler object.
 */ var transformPreventedRoutes = (preventedRoutesMap)=>{
    var preventedRoutesToTransform = _to_consumable_array._(preventedRoutesMap.values());
    var preventedRoutes = preventedRoutesToTransform.reduce((acc, ref)=>{
        var routeKey = ref.routeKey, preventRemove = ref.preventRemove;
        var _acc_routeKey;
        acc[routeKey] = {
            preventRemove: ((_acc_routeKey = acc[routeKey]) === null || _acc_routeKey === void 0 ? void 0 : _acc_routeKey.preventRemove) || preventRemove
        };
        return acc;
    }, {});
    return preventedRoutes;
};
function PreventRemoveProvider(ref) {
    var children = ref.children;
    var _React_useState = _sliced_to_array._(_react.useState(()=>(0, _nonsecure.nanoid)()), 1), parentId = _React_useState[0];
    var _React_useState1 = _sliced_to_array._(_react.useState(()=>new Map()), 2), preventedRoutesMap = _React_useState1[0], setPreventedRoutesMap = _React_useState1[1];
    var navigation = _react.useContext(_NavigationHelpersContext.NavigationHelpersContext);
    var route = _react.useContext(_NavigationRouteContext.NavigationRouteContext);
    var preventRemoveContextValue = _react.useContext(_PreventRemoveContext.PreventRemoveContext);
    // take `setPreventRemove` from parent context - if exist it means we're in a nested context
    var setParentPrevented = preventRemoveContextValue === null || preventRemoveContextValue === void 0 ? void 0 : preventRemoveContextValue.setPreventRemove;
    var setPreventRemove = (0, _uselatestcallback.default)((id, routeKey, preventRemove)=>{
        if (preventRemove && (navigation == null || (navigation === null || navigation === void 0 ? void 0 : navigation.getState().routes.every((route)=>route.key !== routeKey)))) {
            throw new Error(`Couldn't find a route with the key ${routeKey}. Is your component inside NavigationContent?`);
        }
        setPreventedRoutesMap((prevPrevented)=>{
            var _prevPrevented_get, _prevPrevented_get1;
            // values haven't changed - do nothing
            if (routeKey === ((_prevPrevented_get = prevPrevented.get(id)) === null || _prevPrevented_get === void 0 ? void 0 : _prevPrevented_get.routeKey) && preventRemove === ((_prevPrevented_get1 = prevPrevented.get(id)) === null || _prevPrevented_get1 === void 0 ? void 0 : _prevPrevented_get1.preventRemove)) {
                return prevPrevented;
            }
            var nextPrevented = new Map(prevPrevented);
            if (preventRemove) {
                nextPrevented.set(id, {
                    routeKey,
                    preventRemove
                });
            } else {
                nextPrevented.delete(id);
            }
            return nextPrevented;
        });
    });
    var isPrevented = _to_consumable_array._(preventedRoutesMap.values()).some((ref)=>{
        var preventRemove = ref.preventRemove;
        return preventRemove;
    });
    _react.useEffect(()=>{
        if ((route === null || route === void 0 ? void 0 : route.key) !== undefined && setParentPrevented !== undefined) {
            // when route is defined (and setParentPrevented) it means we're in a nested stack
            // route.key then will be the route key of parent
            setParentPrevented(parentId, route.key, isPrevented);
            return ()=>{
                setParentPrevented(parentId, route.key, false);
            };
        }
        return;
    }, [
        parentId,
        isPrevented,
        route === null || route === void 0 ? void 0 : route.key,
        setParentPrevented
    ]);
    var value = _react.useMemo(()=>({
            setPreventRemove,
            preventedRoutes: transformPreventedRoutes(preventedRoutesMap)
        }), [
        setPreventRemove,
        preventedRoutesMap
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_PreventRemoveContext.PreventRemoveContext.Provider, {
        value: value,
        children: children
    });
} //# sourceMappingURL=PreventRemoveProvider.js.map


}),
26296: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "SceneView", ({
    enumerable: true,
    get: function() {
        return SceneView;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _object_without_properties = __webpack_require__(86136);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _EnsureSingleNavigator = __webpack_require__(25569);
var _NavigationFocusedRouteStateContext = __webpack_require__(79646);
var _NavigationStateContext = __webpack_require__(16558);
var _StaticContainer = __webpack_require__(72658);
var _useOptionsGetters = __webpack_require__(50920);
var _jsxruntime = __webpack_require__(70095);
function SceneView(ref) {
    var screen = ref.screen, route = ref.route, navigation = ref.navigation, routeState = ref.routeState, getState = ref.getState, setState = ref.setState, options = ref.options, clearOptions = ref.clearOptions;
    var navigatorKeyRef = _react.useRef(undefined);
    var getKey = _react.useCallback(()=>navigatorKeyRef.current, []);
    var addOptionsGetter = (0, _useOptionsGetters.useOptionsGetters)({
        key: route.key,
        options,
        navigation
    }).addOptionsGetter;
    var setKey = _react.useCallback((key)=>{
        navigatorKeyRef.current = key;
    }, []);
    var getCurrentState = _react.useCallback(()=>{
        var state = getState();
        var currentRoute = state.routes.find((r)=>r.key === route.key);
        return currentRoute ? currentRoute.state : undefined;
    }, [
        getState,
        route.key
    ]);
    var setCurrentState = _react.useCallback((child)=>{
        var state = getState();
        setState(_object_spread_props._(_object_spread._({}, state), {
            routes: state.routes.map((r)=>{
                if (r.key !== route.key) {
                    return r;
                }
                var nextRoute = _object_spread_props._(_object_spread._({}, r), {
                    state: child
                });
                // Before updating the state, cleanup any nested screen and state
                // This will avoid the navigator trying to handle them again
                if (nextRoute.params && ('state' in nextRoute.params && typeof nextRoute.params.state === 'object' && nextRoute.params.state !== null || 'screen' in nextRoute.params && typeof nextRoute.params.screen === 'string')) {
                    // @ts-expect-error: we don't have correct type for params
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    var _nextRoute_params = nextRoute.params, state = _nextRoute_params.state, screen = _nextRoute_params.screen, params = _nextRoute_params.params, initial = _nextRoute_params.initial, rest = _object_without_properties._(_nextRoute_params, [
                        "state",
                        "screen",
                        "params",
                        "initial"
                    ]);
                    if (Object.keys(rest).length) {
                        nextRoute.params = rest;
                    } else {
                        delete nextRoute.params;
                    }
                }
                return nextRoute;
            })
        }));
    }, [
        getState,
        route.key,
        setState
    ]);
    var isInitialRef = _react.useRef(true);
    _react.useEffect(()=>{
        isInitialRef.current = false;
    });
    // Clear options set by this screen when it is unmounted
    _react.useEffect(()=>{
        return clearOptions;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var getIsInitial = _react.useCallback(()=>isInitialRef.current, []);
    var parentFocusedRouteState = _react.useContext(_NavigationFocusedRouteStateContext.NavigationFocusedRouteStateContext);
    var focusedRouteState = _react.useMemo(()=>{
        var state = {
            routes: [
                {
                    key: route.key,
                    name: route.name,
                    params: route.params,
                    path: route.path
                }
            ]
        };
        // Add our state to the innermost route of the parent state
        var addState = (parent)=>{
            var parentRoute = parent === null || parent === void 0 ? void 0 : parent.routes[0];
            if (parentRoute) {
                return {
                    routes: [
                        _object_spread_props._(_object_spread._({}, parentRoute), {
                            state: addState(parentRoute.state)
                        })
                    ]
                };
            }
            return state;
        };
        return addState(parentFocusedRouteState);
    }, [
        parentFocusedRouteState,
        route.key,
        route.name,
        route.params,
        route.path
    ]);
    var context = _react.useMemo(()=>({
            state: routeState,
            getState: getCurrentState,
            setState: setCurrentState,
            getKey,
            setKey,
            getIsInitial,
            addOptionsGetter
        }), [
        routeState,
        getCurrentState,
        setCurrentState,
        getKey,
        setKey,
        getIsInitial,
        addOptionsGetter
    ]);
    var ScreenComponent = screen.getComponent ? screen.getComponent() : screen.component;
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationStateContext.NavigationStateContext.Provider, {
        value: context,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationFocusedRouteStateContext.NavigationFocusedRouteStateContext.Provider, {
            value: focusedRouteState,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_EnsureSingleNavigator.EnsureSingleNavigator, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_StaticContainer.StaticContainer, {
                    name: screen.name,
                    render: ScreenComponent || screen.children,
                    navigation: navigation,
                    route: route,
                    children: ScreenComponent !== undefined ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ScreenComponent, {
                        navigation: navigation,
                        route: route
                    }) : screen.children !== undefined ? screen.children({
                        navigation,
                        route
                    }) : null
                })
            })
        })
    });
} //# sourceMappingURL=SceneView.js.map


}),
38304: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "Screen", ({
    enumerable: true,
    get: function() {
        return Screen;
    }
}));
function Screen(_) {
    /* istanbul ignore next */ return null;
} //# sourceMappingURL=Screen.js.map


}),
72658: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "StaticContainer", ({
    enumerable: true,
    get: function() {
        return StaticContainer;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var StaticContainer = /*#__PURE__*/ _react.memo(function StaticContainer(props) {
    return props.children;
}, (prevProps, nextProps)=>{
    var prevPropKeys = Object.keys(prevProps);
    var nextPropKeys = Object.keys(nextProps);
    if (prevPropKeys.length !== nextPropKeys.length) {
        return false;
    }
    for (var key of prevPropKeys){
        if (key === 'children') {
            continue;
        }
        if (prevProps[key] !== nextProps[key]) {
            return false;
        }
    }
    return true;
}); //# sourceMappingURL=StaticContainer.js.map


}),
39866: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get createComponentForStaticNavigation () {
        return createComponentForStaticNavigation;
    },
    get createPathConfigForStaticNavigation () {
        return createPathConfigForStaticNavigation;
    }
});
var _interop_require_wildcard = __webpack_require__(83610);
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _object_without_properties = __webpack_require__(86136);
var _sliced_to_array = __webpack_require__(78474);
var _to_consumable_array = __webpack_require__(92716);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _reactis = __webpack_require__(37899);
var _useRoute = __webpack_require__(30692);
var _jsxruntime = __webpack_require__(70095);
var MemoizedScreen = /*#__PURE__*/ _react.memo((ref)=>{
    var component = ref.component;
    var route = (0, _useRoute.useRoute)();
    var children = /*#__PURE__*/ _react.createElement(component, {
        route
    });
    return children;
});
MemoizedScreen.displayName = 'Memo(Screen)';
var getItemsFromScreens = (Screen, screens)=>{
    return Object.entries(screens).map((ref)=>{
        var _ref = _sliced_to_array._(ref, 2), name = _ref[0], item = _ref[1];
        var component;
        var props = {};
        var useIf;
        var isNavigator = false;
        if ('screen' in item) {
            var screen = item.screen, _if = item.if, rest = _object_without_properties._(item, [
                "screen",
                "if"
            ]);
            useIf = _if;
            props = rest;
            if ((0, _reactis.isValidElementType)(screen)) {
                component = screen;
            } else if ('config' in screen) {
                isNavigator = true;
                component = createComponentForStaticNavigation(screen, `${name}Navigator`);
            }
        } else if ((0, _reactis.isValidElementType)(item)) {
            component = item;
        } else if ('config' in item) {
            isNavigator = true;
            component = createComponentForStaticNavigation(item, `${name}Navigator`);
        }
        if (component == null) {
            throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);
        }
        var element = isNavigator ? /*#__PURE__*/ _react.createElement(component, {}) : /*#__PURE__*/ (0, _jsxruntime.jsx)(MemoizedScreen, {
            component: component
        });
        return ()=>{
            var shouldRender = useIf == null || useIf();
            if (!shouldRender) {
                return null;
            }
            return /*#__PURE__*/ (0, _jsxruntime.jsx)(Screen, _object_spread_props._(_object_spread._({
                name: name
            }, props), {
                children: ()=>element
            }), name);
        };
    });
};
function createComponentForStaticNavigation(tree, displayName) {
    var Navigator = tree.Navigator, Group = tree.Group, Screen = tree.Screen, config = tree.config;
    var screens = config.screens, groups = config.groups, rest = _object_without_properties._(config, [
        "screens",
        "groups"
    ]);
    if (screens == null && groups == null) {
        throw new Error("Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.");
    }
    var items = [];
    // Loop through the config to find screens and groups
    // So we add the screens and groups in the same order as they are defined
    for(var _ref in config){
        var key = _ref;
        if (key === 'screens' && screens) {
            var _items;
            (_items = items).push.apply(_items, _to_consumable_array._(getItemsFromScreens(Screen, screens)));
        }
        if (key === 'groups' && groups) {
            var _items1;
            (_items1 = items).push.apply(_items1, _to_consumable_array._(Object.entries(groups).map((_param)=>{
                var _$_param = _sliced_to_array._(_param, 2), key = _$_param[0], _param_ = _$_param[1], useIf = _param_.if, group = _object_without_properties._(_param[1], [
                    "if"
                ]);
                var groupItems = getItemsFromScreens(Screen, group.screens);
                return ()=>{
                    // Call unconditionally since screen configs may contain `useIf` hooks
                    var children = groupItems.map((item)=>item());
                    var shouldRender = useIf == null || useIf();
                    if (!shouldRender) {
                        return null;
                    }
                    return /*#__PURE__*/ (0, _jsxruntime.jsx)(Group, _object_spread_props._(_object_spread._({
                        navigationKey: key
                    }, group), {
                        children: children
                    }), key);
                };
            })));
        }
    }
    var NavigatorComponent = ()=>{
        var children = items.map((item)=>item());
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Navigator, _object_spread_props._(_object_spread._({}, rest), {
            children: children
        }));
    };
    NavigatorComponent.displayName = displayName;
    return NavigatorComponent;
}
function createPathConfigForStaticNavigation(tree, options, auto) {
    var initialScreenConfig;
    var createPathConfigForTree = (t, o, skipInitialDetection)=>{
        var createPathConfigForScreens = (screens, initialRouteName)=>{
            return Object.fromEntries(Object.entries(screens)// Re-order to move the initial route to the front
            // This way we can detect the initial route correctly
            .sort((ref, ref1)=>{
                var _ref = _sliced_to_array._(ref, 1), a = _ref[0], _ref1 = _sliced_to_array._(ref1, 1), b = _ref1[0];
                if (a === initialRouteName) {
                    return -1;
                }
                if (b === initialRouteName) {
                    return 1;
                }
                return 0;
            }).map((ref)=>{
                var _ref = _sliced_to_array._(ref, 2), key = _ref[0], item = _ref[1];
                var screenConfig = {};
                if ('linking' in item) {
                    if (typeof item.linking === 'string') {
                        screenConfig.path = item.linking;
                    } else {
                        Object.assign(screenConfig, item.linking);
                    }
                    if (typeof screenConfig.path === 'string') {
                        screenConfig.path = screenConfig.path.replace(/^\//, '') // Remove extra leading slash
                        .replace(/\/$/, ''); // Remove extra trailing slash
                    }
                }
                var _$screens;
                var skipInitialDetectionInChild = skipInitialDetection || screenConfig.path != null && screenConfig.path !== '';
                if ('config' in item) {
                    _$screens = createPathConfigForTree(item, undefined, skipInitialDetectionInChild);
                } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {
                    _$screens = createPathConfigForTree(item.screen, undefined, skipInitialDetectionInChild);
                }
                if (_$screens) {
                    screenConfig.screens = _$screens;
                }
                if (auto && !screenConfig.screens && // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly
                !('linking' in item && item.linking == null)) {
                    if (screenConfig.path != null) {
                        if (!skipInitialDetection && screenConfig.path === '') {
                            // We encounter a leaf screen with empty path,
                            // Clear the initial screen config as it's not needed anymore
                            initialScreenConfig = undefined;
                        }
                    } else {
                        if (!skipInitialDetection && initialScreenConfig == null) {
                            initialScreenConfig = screenConfig;
                        }
                        screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();
                    }
                }
                return [
                    key,
                    screenConfig
                ];
            }).filter((ref)=>{
                var _ref = _sliced_to_array._(ref, 2), screen = _ref[1];
                return Object.keys(screen).length > 0;
            }));
        };
        var screens = {};
        // Loop through the config to find screens and groups
        // So we add the screens and groups in the same order as they are defined
        for(var key in t.config){
            if (key === 'screens' && t.config.screens) {
                Object.assign(screens, createPathConfigForScreens(t.config.screens, (o === null || o === void 0 ? void 0 : o.initialRouteName) ?? t.config.initialRouteName));
            }
            if (key === 'groups' && t.config.groups) {
                Object.entries(t.config.groups).forEach((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), group = _ref[1];
                    Object.assign(screens, createPathConfigForScreens(group.screens, (o === null || o === void 0 ? void 0 : o.initialRouteName) ?? t.config.initialRouteName));
                });
            }
        }
        if (Object.keys(screens).length === 0) {
            return undefined;
        }
        return screens;
    };
    var screens = createPathConfigForTree(tree, options, false);
    if (auto && initialScreenConfig) {
        initialScreenConfig.path = '';
    }
    return screens;
} //# sourceMappingURL=StaticNavigation.js.map


}),
16497: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "UnhandledActionContext", ({
    enumerable: true,
    get: function() {
        return UnhandledActionContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var UnhandledActionContext = /*#__PURE__*/ _react.createContext(undefined); //# sourceMappingURL=UnhandledActionContext.js.map


}),
28278: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "arrayStartsWith", ({
    enumerable: true,
    get: function() {
        return arrayStartsWith;
    }
}));
function arrayStartsWith(array, start) {
    if (start.length > array.length) {
        return false;
    }
    return start.every((it, index)=>it === array[index]);
} //# sourceMappingURL=arrayStartsWith.js.map


}),
70349: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "checkDuplicateRouteNames", ({
    enumerable: true,
    get: function() {
        return checkDuplicateRouteNames;
    }
}));
function checkDuplicateRouteNames(state) {
    var duplicates = [];
    var getRouteNames = (location, state)=>{
        state.routes.forEach((route)=>{
            var _route_state_routeNames, _route_state;
            var currentLocation = location ? `${location} > ${route.name}` : route.name;
            (_route_state = route.state) === null || _route_state === void 0 ? void 0 : (_route_state_routeNames = _route_state.routeNames) === null || _route_state_routeNames === void 0 ? void 0 : _route_state_routeNames.forEach((routeName)=>{
                if (routeName === route.name) {
                    duplicates.push([
                        currentLocation,
                        `${currentLocation} > ${route.name}`
                    ]);
                }
            });
            if (route.state) {
                getRouteNames(currentLocation, route.state);
            }
        });
    };
    getRouteNames('', state);
    return duplicates;
} //# sourceMappingURL=checkDuplicateRouteNames.js.map


}),
65697: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "checkSerializable", ({
    enumerable: true,
    get: function() {
        return checkSerializable;
    }
}));
var _to_consumable_array = __webpack_require__(92716);
var checkSerializableWithoutCircularReference = (o, seen, location)=>{
    if (o === undefined || o === null || typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string') {
        return {
            serializable: true
        };
    }
    if (Object.prototype.toString.call(o) !== '[object Object]' && !Array.isArray(o)) {
        return {
            serializable: false,
            location,
            reason: typeof o === 'function' ? 'Function' : String(o)
        };
    }
    if (seen.has(o)) {
        return {
            serializable: false,
            reason: 'Circular reference',
            location
        };
    }
    seen.add(o);
    if (Array.isArray(o)) {
        for(var i = 0; i < o.length; i++){
            var childResult = checkSerializableWithoutCircularReference(o[i], new Set(seen), _to_consumable_array._(location).concat([
                i
            ]));
            if (!childResult.serializable) {
                return childResult;
            }
        }
    } else {
        for(var key in o){
            var childResult1 = checkSerializableWithoutCircularReference(o[key], new Set(seen), _to_consumable_array._(location).concat([
                key
            ]));
            if (!childResult1.serializable) {
                return childResult1;
            }
        }
    }
    return {
        serializable: true
    };
};
function checkSerializable(o) {
    return checkSerializableWithoutCircularReference(o, new Set(), []);
} //# sourceMappingURL=checkSerializable.js.map


}),
52249: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get NOT_INITIALIZED_ERROR () {
        return NOT_INITIALIZED_ERROR;
    },
    get createNavigationContainerRef () {
        return createNavigationContainerRef;
    }
});
var _object_spread = __webpack_require__(36192);
var _sliced_to_array = __webpack_require__(78474);
var _to_consumable_array = __webpack_require__(92716);
var _routers = __webpack_require__(93675);
var NOT_INITIALIZED_ERROR = "The 'navigation' object hasn't been initialized yet. This might happen if you don't have a navigator mounted, or if the navigator hasn't finished mounting. See https://reactnavigation.org/docs/navigating-without-navigation-prop#handling-initialization for more details.";
function createNavigationContainerRef() {
    var methods = _to_consumable_array._(Object.keys(_routers.CommonActions)).concat([
        'addListener',
        'removeListener',
        'resetRoot',
        'dispatch',
        'isFocused',
        'canGoBack',
        'getRootState',
        'getState',
        'getParent',
        'getCurrentRoute',
        'getCurrentOptions'
    ]);
    var listeners = {};
    var removeListener = (event, callback)=>{
        if (listeners[event]) {
            listeners[event] = listeners[event].filter((cb)=>cb !== callback);
        }
    };
    var current = null;
    var ref = _object_spread._({
        get current () {
            return current;
        },
        set current (value){
            current = value;
            if (value != null) {
                Object.entries(listeners).forEach((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), event = _ref[0], callbacks = _ref[1];
                    callbacks.forEach((callback)=>{
                        value.addListener(event, callback);
                    });
                });
            }
        },
        isReady: ()=>{
            if (current == null) {
                return false;
            }
            return current.isReady();
        }
    }, methods.reduce((acc, name)=>{
        acc[name] = (...args)=>{
            if (current == null) {
                switch(name){
                    case 'addListener':
                        {
                            var _args = _sliced_to_array._(args, 2), event = _args[0], callback = _args[1];
                            listeners[event] = listeners[event] || [];
                            listeners[event].push(callback);
                            return ()=>removeListener(event, callback);
                        }
                    case 'removeListener':
                        {
                            var _args1 = _sliced_to_array._(args, 2), event1 = _args1[0], callback1 = _args1[1];
                            removeListener(event1, callback1);
                            break;
                        }
                    default:
                        console.error(NOT_INITIALIZED_ERROR);
                }
            } else {
                var _current;
                // @ts-expect-error: this is ok
                return (_current = current)[name].apply(_current, _to_consumable_array._(args));
            }
        };
        return acc;
    }, {}));
    return ref;
} //# sourceMappingURL=createNavigationContainerRef.js.map


}),
72591: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createNavigatorFactory", ({
    enumerable: true,
    get: function() {
        return createNavigatorFactory;
    }
}));
var _Group = __webpack_require__(44052);
var _Screen = __webpack_require__(38304);
function createNavigatorFactory(Navigator) {
    function createNavigator(config) {
        if (config != null) {
            return {
                Navigator,
                Screen: _Screen.Screen,
                Group: _Group.Group,
                config
            };
        }
        return {
            Navigator,
            Screen: _Screen.Screen,
            Group: _Group.Group
        };
    }
    return createNavigator;
} //# sourceMappingURL=createNavigatorFactory.js.map


}),
5552: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get deepFreeze () {
        return deepFreeze;
    },
    get isPlainObject () {
        return isPlainObject;
    }
});
var isPlainObject = (value)=>{
    if (typeof value === 'object' && value !== null) {
        return Object.getPrototypeOf(value) === Object.prototype;
    }
    return false;
};
var deepFreeze = (object)=>{
    // We only freeze in development to catch issues early
    // Don't freeze in production to avoid unnecessary performance overhead
    if (true) {
        return object;
    }
    if (Object.isFrozen(object)) {
        return object;
    }
    if (!isPlainObject(object) && !Array.isArray(object)) {
        return object;
    }
    // Freeze properties before freezing self
    for(var key in object){
        // Don't freeze objects in params since they are passed by the user
        if (key !== 'params') {
            var _Object_getOwnPropertyDescriptor;
            if ((_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(object, key)) === null || _Object_getOwnPropertyDescriptor === void 0 ? void 0 : _Object_getOwnPropertyDescriptor.configurable) {
                var value = object[key];
                deepFreeze(value);
            }
        }
    }
    return Object.freeze(object);
}; //# sourceMappingURL=deepFreeze.js.map


}),
86363: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "findFocusedRoute", ({
    enumerable: true,
    get: function() {
        return findFocusedRoute;
    }
}));
function findFocusedRoute(state) {
    var current = state;
    while((current === null || current === void 0 ? void 0 : current.routes[current.index ?? 0].state) != null){
        current = current.routes[current.index ?? 0].state;
    }
    var route = current === null || current === void 0 ? void 0 : current.routes[(current === null || current === void 0 ? void 0 : current.index) ?? 0];
    return route;
} //# sourceMappingURL=findFocusedRoute.js.map


}),
35808: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getActionFromState", ({
    enumerable: true,
    get: function() {
        return getActionFromState;
    }
}));
var _object_spread = __webpack_require__(36192);
var _sliced_to_array = __webpack_require__(78474);
function getActionFromState(state, options) {
    var _normalizedConfig_screens;
    // Create a normalized configs object which will be easier to use
    var normalizedConfig = options ? createNormalizedConfigItem(options) : {};
    var routes = state.index != null ? state.routes.slice(0, state.index + 1) : state.routes;
    if (routes.length === 0) {
        return undefined;
    }
    if (!(routes.length === 1 && routes[0].key === undefined || routes.length === 2 && routes[0].key === undefined && routes[0].name === (normalizedConfig === null || normalizedConfig === void 0 ? void 0 : normalizedConfig.initialRouteName) && routes[1].key === undefined)) {
        return {
            type: 'RESET',
            payload: state
        };
    }
    var route = state.routes[state.index ?? state.routes.length - 1];
    var current = route === null || route === void 0 ? void 0 : route.state;
    var config = normalizedConfig === null || normalizedConfig === void 0 ? void 0 : (_normalizedConfig_screens = normalizedConfig.screens) === null || _normalizedConfig_screens === void 0 ? void 0 : _normalizedConfig_screens[route === null || route === void 0 ? void 0 : route.name];
    var params = _object_spread._({}, route.params);
    var payload = route ? {
        name: route.name,
        path: route.path,
        params
    } : undefined;
    // If the screen contains a navigator, pop other screens to navigate to it
    // This avoid pushing multiple instances of navigators onto a stack
    //
    // For example:
    // - RootStack
    //   - BottomTabs
    //   - SomeScreen
    //
    // In this case, if deep linking to `BottomTabs`, we should pop `SomeScreen`
    // Otherwise, we'll end up with 2 instances of `BottomTabs` in the stack
    //
    // There are 2 ways we can detect if a screen contains a navigator:
    // - The route contains nested state in `route.state`
    // - Nested screens are defined in the config
    if (payload && (config === null || config === void 0 ? void 0 : config.screens) && Object.keys(config.screens).length) {
        payload.pop = true;
    }
    while(current){
        var _config_screens;
        if (current.routes.length === 0) {
            return undefined;
        }
        var routes1 = current.index != null ? current.routes.slice(0, current.index + 1) : current.routes;
        var route1 = routes1[routes1.length - 1];
        // Explicitly set to override existing value when merging params
        Object.assign(params, {
            initial: undefined,
            screen: undefined,
            params: undefined,
            state: undefined
        });
        if (routes1.length === 1 && routes1[0].key === undefined) {
            params.initial = true;
            params.screen = route1.name;
        } else if (routes1.length === 2 && routes1[0].key === undefined && routes1[0].name === (config === null || config === void 0 ? void 0 : config.initialRouteName) && routes1[1].key === undefined) {
            params.initial = false;
            params.screen = route1.name;
        } else {
            params.state = current;
            break;
        }
        if (route1.state) {
            params.params = _object_spread._({}, route1.params);
            params.pop = true;
            params = params.params;
        } else {
            params.path = route1.path;
            params.params = route1.params;
        }
        current = route1.state;
        config = config === null || config === void 0 ? void 0 : (_config_screens = config.screens) === null || _config_screens === void 0 ? void 0 : _config_screens[route1.name];
        if ((config === null || config === void 0 ? void 0 : config.screens) && Object.keys(config.screens).length) {
            params.pop = true;
        }
    }
    if ((payload === null || payload === void 0 ? void 0 : payload.params.screen) || (payload === null || payload === void 0 ? void 0 : payload.params.state)) {
        payload.pop = true;
    }
    if (!payload) {
        return;
    }
    // Try to construct payload for a `NAVIGATE` action from the state
    // This lets us preserve the navigation state and not lose it
    return {
        type: 'NAVIGATE',
        payload
    };
}
var createNormalizedConfigItem = (config)=>typeof config === 'object' && config != null ? {
        initialRouteName: config.initialRouteName,
        screens: config.screens != null ? createNormalizedConfigs(config.screens) : undefined
    } : {};
var createNormalizedConfigs = (options)=>Object.entries(options).reduce((acc, ref)=>{
        var _ref = _sliced_to_array._(ref, 2), k = _ref[0], v = _ref[1];
        acc[k] = createNormalizedConfigItem(v);
        return acc;
    }, {}); //# sourceMappingURL=getActionFromState.js.map


}),
31970: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getFocusedRouteNameFromRoute", ({
    enumerable: true,
    get: function() {
        return getFocusedRouteNameFromRoute;
    }
}));
var _useRouteCache = __webpack_require__(62289);
function getFocusedRouteNameFromRoute(route) {
    // @ts-expect-error: this isn't in type definitions coz we want this private
    var state = route[_useRouteCache.CHILD_STATE] ?? route.state;
    var params = route.params;
    var routeName = state ? // Get the currently active route name in the nested navigator
    state.routes[// If we have a partial state without index, for tab/drawer, first screen will be focused one, and last for stack
    // The type property will only exist for rehydrated state and not for state from deep link
    state.index ?? (typeof state.type === 'string' && state.type !== 'stack' ? 0 : state.routes.length - 1)].name : // If state doesn't exist, we need to default to `screen` param if available
    typeof (params === null || params === void 0 ? void 0 : params.screen) === 'string' ? params.screen : undefined;
    return routeName;
} //# sourceMappingURL=getFocusedRouteNameFromRoute.js.map


}),
73099: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getPathFromState", ({
    enumerable: true,
    get: function() {
        return getPathFromState;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _object_spread = __webpack_require__(36192);
var _sliced_to_array = __webpack_require__(78474);
var _to_consumable_array = __webpack_require__(92716);
var _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(26930));
var _getPatternParts = __webpack_require__(28963);
var _validatePathConfig = __webpack_require__(33434);
var getActiveRoute = (state)=>{
    var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];
    if (route.state) {
        return getActiveRoute(route.state);
    }
    return route;
};
var cachedNormalizedConfigs = new WeakMap();
var getNormalizedConfigs = (options)=>{
    if (!(options === null || options === void 0 ? void 0 : options.screens)) return {};
    var cached = cachedNormalizedConfigs.get(options === null || options === void 0 ? void 0 : options.screens);
    if (cached) return cached;
    var normalizedConfigs = createNormalizedConfigs(options.screens);
    cachedNormalizedConfigs.set(options.screens, normalizedConfigs);
    return normalizedConfigs;
};
function getPathFromState(state, options) {
    var _loop = function() {
        var _loop = function() {
            parts = currentOptions[route.name].parts;
            nestedRouteNames.push(route.name);
            if (route.params) {
                var _$options = currentOptions[route.name];
                var currentParams = Object.fromEntries(Object.entries(route.params).map((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                    var _options_stringify;
                    if (value === undefined) {
                        if (_$options) {
                            var _options_parts_find, _options_parts;
                            var optional = (_options_parts = _$options.parts) === null || _options_parts === void 0 ? void 0 : (_options_parts_find = _options_parts.find((part)=>part.param === key)) === null || _options_parts_find === void 0 ? void 0 : _options_parts_find.optional;
                            if (optional) {
                                return null;
                            }
                        } else {
                            return null;
                        }
                    }
                    var stringify = (_$options === null || _$options === void 0 ? void 0 : (_options_stringify = _$options.stringify) === null || _options_stringify === void 0 ? void 0 : _options_stringify[key]) ?? String;
                    return [
                        key,
                        stringify(value)
                    ];
                }).filter((entry)=>entry != null));
                if (parts === null || parts === void 0 ? void 0 : parts.length) {
                    Object.assign(allParams, currentParams);
                }
                if (focusedRoute === route) {
                    // If this is the focused route, keep the params for later use
                    // We save it here since it's been stringified already
                    focusedParams = _object_spread._({}, currentParams);
                    parts === null || parts === void 0 ? void 0 : parts.forEach((ref)=>{
                        var param = ref.param;
                        if (param) {
                            // Remove the params present in the pattern since we'll only use the rest for query string
                            if (focusedParams) {
                                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                                delete focusedParams[param];
                            }
                        }
                    });
                }
            }
            // If there is no `screens` property or no nested state, we return pattern
            if (!currentOptions[route.name].screens || route.state === undefined) {
                hasNext = false;
            } else {
                index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;
                var nextRoute = route.state.routes[index];
                var nestedConfig = currentOptions[route.name].screens;
                // if there is config for next route name, we go deeper
                if (nestedConfig && nextRoute.name in nestedConfig) {
                    route = nextRoute;
                    currentOptions = nestedConfig;
                } else {
                    // If not, there is no sense in going deeper in config
                    hasNext = false;
                }
            }
        };
        var index = typeof current.index === 'number' ? current.index : 0;
        var route = current.routes[index];
        var parts = void 0;
        var focusedParams = void 0;
        var currentOptions = configs;
        var focusedRoute = getActiveRoute(state);
        // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined
        var nestedRouteNames = [];
        var hasNext = true;
        while(route.name in currentOptions && hasNext)_loop();
        if (currentOptions[route.name] !== undefined) {
            path += parts === null || parts === void 0 ? void 0 : parts.map((ref)=>{
                var segment = ref.segment, param = ref.param, optional = ref.optional;
                // We don't know what to show for wildcard patterns
                // Showing the route name seems ok, though whatever we show here will be incorrect
                // Since the page doesn't actually exist
                if (segment === '*') {
                    return route.name;
                }
                // If the path has a pattern for a param, put the param in the path
                if (param) {
                    var value = allParams[param];
                    if (value === undefined && optional) {
                        // Optional params without value assigned in route.params should be ignored
                        return '';
                    }
                    // Valid characters according to
                    // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)
                    return String(value).replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]/g, (char)=>encodeURIComponent(char));
                }
                return encodeURIComponent(segment);
            }).join('/');
        } else {
            path += encodeURIComponent(route.name);
        }
        if (!focusedParams && focusedRoute.params) {
            focusedParams = Object.fromEntries(Object.entries(focusedRoute.params).map((ref)=>{
                var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                return [
                    key,
                    String(value)
                ];
            }));
        }
        if (route.state) {
            path += '/';
        } else if (focusedParams) {
            for(var param in focusedParams){
                if (focusedParams[param] === 'undefined') {
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete focusedParams[param];
                }
            }
            var query = _querystring.stringify(focusedParams, {
                sort: false
            });
            if (query) {
                path += `?${query}`;
            }
        }
        current = route.state;
    };
    if (state == null) {
        throw Error(`Got '${String(state)}' for the navigation state. You must pass a valid state object.`);
    }
    if (options) {
        (0, _validatePathConfig.validatePathConfig)(options);
    }
    var configs = getNormalizedConfigs(options);
    var path = '/';
    var current = state;
    var allParams = {};
    while(current)_loop();
    // Include the root path if specified
    if (options === null || options === void 0 ? void 0 : options.path) {
        path = `${options.path}/${path}`;
    }
    // Remove multiple as well as trailing slashes
    path = path.replace(/\/+/g, '/');
    path = path.length > 1 ? path.replace(/\/$/, '') : path;
    // If path doesn't start with a slash, add it
    // This makes sure that history.pushState will update the path correctly instead of appending
    if (!path.startsWith('/')) {
        path = `/${path}`;
    }
    return path;
}
var createConfigItem = (config, parentParts)=>{
    if (typeof config === 'string') {
        // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
        var parts = (0, _getPatternParts.getPatternParts)(config);
        if (parentParts) {
            return {
                parts: _to_consumable_array._(parentParts).concat(_to_consumable_array._(parts))
            };
        }
        return {
            parts
        };
    }
    if (config.exact && config.path === undefined) {
        throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
    }
    // If an object is specified as the value (e.g. Foo: { ... }),
    // It can have `path` property and `screens` prop which has nested configs
    var parts1 = config.exact !== true ? _to_consumable_array._(parentParts || []).concat(_to_consumable_array._(config.path ? (0, _getPatternParts.getPatternParts)(config.path) : [])) : config.path ? (0, _getPatternParts.getPatternParts)(config.path) : undefined;
    var screens = config.screens ? createNormalizedConfigs(config.screens, parts1) : undefined;
    return {
        parts: parts1,
        stringify: config.stringify,
        screens
    };
};
var createNormalizedConfigs = (options, parts)=>Object.fromEntries(Object.entries(options).map((ref)=>{
        var _ref = _sliced_to_array._(ref, 2), name = _ref[0], c = _ref[1];
        var result = createConfigItem(c, parts);
        return [
            name,
            result
        ];
    })); //# sourceMappingURL=getPathFromState.js.map


}),
28963: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getPatternParts", ({
    enumerable: true,
    get: function() {
        return getPatternParts;
    }
}));
var _sliced_to_array = __webpack_require__(78474);
function getPatternParts(path) {
    var parts = [];
    var current = {
        segment: ''
    };
    var isRegex = false;
    var isParam = false;
    var regexInnerParens = 0;
    // One extra iteration to add the last character
    for(var i = 0; i <= path.length; i++){
        var char = path[i];
        if (char != null) {
            current.segment += char;
        }
        if (char === ':') {
            // The segment must start with a colon if it's a param
            if (current.segment === ':') {
                isParam = true;
            } else if (!isRegex) {
                throw new Error(`Encountered ':' in the middle of a segment in path: ${path}`);
            }
        } else if (char === '(') {
            if (isParam) {
                if (isRegex) {
                    // The '(' is part of the regex if we're already inside one
                    regexInnerParens++;
                } else {
                    isRegex = true;
                }
            } else {
                throw new Error(`Encountered '(' without preceding ':' in path: ${path}`);
            }
        } else if (char === ')') {
            if (isParam && isRegex) {
                if (regexInnerParens) {
                    // The ')' is part of the regex if we're already inside one
                    regexInnerParens--;
                    current.regex += char;
                } else {
                    isRegex = false;
                    isParam = false;
                }
            } else {
                throw new Error(`Encountered ')' without preceding '(' in path: ${path}`);
            }
        } else if (char === '?') {
            if (current.param) {
                isParam = false;
                current.optional = true;
            } else {
                throw new Error(`Encountered '?' without preceding ':' in path: ${path}`);
            }
        } else if (char == null || char === '/' && !isRegex) {
            isParam = false;
            // Remove trailing slash from segment
            current.segment = current.segment.replace(/\/$/, '');
            if (current.segment === '') {
                continue;
            }
            if (current.param) {
                current.param = current.param.replace(/^:/, '');
            }
            if (current.regex) {
                current.regex = current.regex.replace(/^\(/, '').replace(/\)$/, '');
            }
            parts.push(current);
            if (char == null) {
                break;
            }
            current = {
                segment: ''
            };
        }
        if (isRegex) {
            current.regex = current.regex || '';
            current.regex += char;
        }
        if (isParam && !isRegex) {
            current.param = current.param || '';
            current.param += char;
        }
    }
    if (isRegex) {
        throw new Error(`Could not find closing ')' in path: ${path}`);
    }
    var params = parts.map((part)=>part.param).filter(Boolean);
    for (var ref of params.entries()){
        var _ref = _sliced_to_array._(ref, 2), index = _ref[0], param = _ref[1];
        if (params.indexOf(param) !== index) {
            throw new Error(`Duplicate param name '${param}' found in path: ${path}`);
        }
    }
    return parts;
} //# sourceMappingURL=getPatternParts.js.map


}),
99682: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getStateFromPath", ({
    enumerable: true,
    get: function() {
        return getStateFromPath;
    }
}));
var _interop_require_default = __webpack_require__(66705);
var _interop_require_wildcard = __webpack_require__(83610);
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _sliced_to_array = __webpack_require__(78474);
var _to_consumable_array = __webpack_require__(92716);
var _escapestringregexp = /*#__PURE__*/ _interop_require_default._(__webpack_require__(48070));
var _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(26930));
var _arrayStartsWith = __webpack_require__(28278);
var _findFocusedRoute = __webpack_require__(86363);
var _getPatternParts = __webpack_require__(28963);
var _isArrayEqual = __webpack_require__(3311);
var _validatePathConfig = __webpack_require__(33434);
function getStateFromPath(path, options) {
    var _options_path;
    var _getConfigResources = getConfigResources(options), initialRoutes = _getConfigResources.initialRoutes, configs = _getConfigResources.configs;
    var screens = options === null || options === void 0 ? void 0 : options.screens;
    var remaining = path.replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
    .replace(/^\//, '') // Remove extra leading slash
    .replace(/\?.*$/, ''); // Remove query params which we will handle later
    // Make sure there is a trailing slash
    remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;
    var prefix = options === null || options === void 0 ? void 0 : (_options_path = options.path) === null || _options_path === void 0 ? void 0 : _options_path.replace(/^\//, ''); // Remove extra leading slash
    if (prefix) {
        // Make sure there is a trailing slash
        var normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;
        // If the path doesn't start with the prefix, it's not a match
        if (!remaining.startsWith(normalizedPrefix)) {
            return undefined;
        }
        // Remove the prefix from the path
        remaining = remaining.replace(normalizedPrefix, '');
    }
    if (screens === undefined) {
        // When no config is specified, use the path segments as route names
        var routes = remaining.split('/').filter(Boolean).map((segment)=>{
            var name = decodeURIComponent(segment);
            return {
                name
            };
        });
        if (routes.length) {
            return createNestedStateObject(path, routes, initialRoutes);
        }
        return undefined;
    }
    if (remaining === '/') {
        // We need to add special handling of empty path so navigation to empty path also works
        // When handling empty path, we should only look at the root level config
        var match = configs.find((config)=>config.segments.join('/') === '');
        if (match) {
            return createNestedStateObject(path, match.routeNames.map((name)=>({
                    name
                })), initialRoutes, configs);
        }
        return undefined;
    }
    var result;
    var current;
    // We match the whole path against the regex instead of segments
    // This makes sure matches such as wildcard will catch any unmatched routes, even if nested
    var _matchAgainstConfigs = matchAgainstConfigs(remaining, configs), routes1 = _matchAgainstConfigs.routes, remainingPath = _matchAgainstConfigs.remainingPath;
    if (routes1 !== undefined) {
        // This will always be empty if full path matched
        current = createNestedStateObject(path, routes1, initialRoutes, configs);
        remaining = remainingPath;
        result = current;
    }
    if (current == null || result == null) {
        return undefined;
    }
    return result;
}
/**
 * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.
 */ var cachedConfigResources = new WeakMap();
function getConfigResources(options) {
    if (!options) return prepareConfigResources();
    var cached = cachedConfigResources.get(options);
    if (cached) return cached;
    var resources = prepareConfigResources(options);
    cachedConfigResources.set(options, resources);
    return resources;
}
function prepareConfigResources(options) {
    if (options) {
        (0, _validatePathConfig.validatePathConfig)(options);
    }
    var initialRoutes = getInitialRoutes(options);
    var configs = getSortedNormalizedConfigs(initialRoutes, options === null || options === void 0 ? void 0 : options.screens);
    checkForDuplicatedConfigs(configs);
    var configWithRegexes = getConfigsWithRegexes(configs);
    return {
        initialRoutes,
        configs,
        configWithRegexes
    };
}
function getInitialRoutes(options) {
    var initialRoutes = [];
    if (options === null || options === void 0 ? void 0 : options.initialRouteName) {
        initialRoutes.push({
            initialRouteName: options.initialRouteName,
            parentScreens: []
        });
    }
    return initialRoutes;
}
function getSortedNormalizedConfigs(initialRoutes, ref) {
    var screens = ref === void 0 ? {} : ref;
    var _instance;
    // Create a normalized configs array which will be easier to use
    return (_instance = []).concat.apply(_instance, _to_consumable_array._(Object.keys(screens).map((key)=>createNormalizedConfigs(key, screens, initialRoutes, [], [], [])))).sort((a, b)=>{
        // Sort config from most specific to least specific:
        // - more segments
        // - static segments
        // - params with regex
        // - regular params
        // - wildcard
        // If 2 patterns are same, move the one with less route names up
        // This is an error state, so it's only useful for consistent error messages
        if ((0, _isArrayEqual.isArrayEqual)(a.segments, b.segments)) {
            return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
        }
        // If one of the patterns starts with the other, it's more exhaustive
        // So move it up
        if ((0, _arrayStartsWith.arrayStartsWith)(a.segments, b.segments)) {
            return -1;
        }
        if ((0, _arrayStartsWith.arrayStartsWith)(b.segments, a.segments)) {
            return 1;
        }
        for(var i = 0; i < Math.max(a.segments.length, b.segments.length); i++){
            // if b is longer, b gets higher priority
            if (a.segments[i] == null) {
                return 1;
            }
            // if a is longer, a gets higher priority
            if (b.segments[i] == null) {
                return -1;
            }
            var aWildCard = a.segments[i] === '*';
            var bWildCard = b.segments[i] === '*';
            var aParam = a.segments[i].startsWith(':');
            var bParam = b.segments[i].startsWith(':');
            var aRegex = aParam && a.segments[i].includes('(');
            var bRegex = bParam && b.segments[i].includes('(');
            // if both are wildcard or regex, we compare next component
            if (aWildCard && bWildCard || aRegex && bRegex) {
                continue;
            }
            // if only a is wildcard, b gets higher priority
            if (aWildCard && !bWildCard) {
                return 1;
            }
            // if only b is wildcard, a gets higher priority
            if (bWildCard && !aWildCard) {
                return -1;
            }
            // If only a has a param, b gets higher priority
            if (aParam && !bParam) {
                return 1;
            }
            // If only b has a param, a gets higher priority
            if (bParam && !aParam) {
                return -1;
            }
            // if only a has regex, a gets higher priority
            if (aRegex && !bRegex) {
                return -1;
            }
            // if only b has regex, b gets higher priority
            if (bRegex && !aRegex) {
                return 1;
            }
        }
        return a.segments.length - b.segments.length;
    });
}
function checkForDuplicatedConfigs(configs) {
    // Check for duplicate patterns in the config
    configs.reduce((acc, config)=>{
        var pattern = config.segments.join('/');
        if (acc[pattern]) {
            var a = acc[pattern].routeNames;
            var b = config.routeNames;
            // It's not a problem if the path string omitted from a inner most screen
            // For example, it's ok if a path resolves to `A > B > C` or `A > B`
            var intersects = a.length > b.length ? b.every((it, i)=>a[i] === it) : a.every((it, i)=>b[i] === it);
            if (!intersects) {
                throw new Error(`Found conflicting screens with the same pattern. The pattern '${pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);
            }
        }
        return Object.assign(acc, {
            [pattern]: config
        });
    }, {});
}
function getConfigsWithRegexes(configs) {
    return configs.map((c)=>_object_spread_props._(_object_spread._({}, c), {
            // Add `$` to the regex to make sure it matches till end of the path and not just beginning
            regex: c.regex ? new RegExp(c.regex.source + '$') : undefined
        }));
}
var matchAgainstConfigs = (remaining, configs)=>{
    var _loop = function(config) {
        if (!config.regex) {
            return "continue";
        }
        var match = remainingPath.match(config.regex);
        // If our regex matches, we need to extract params from the path
        if (match) {
            routes = config.routeNames.map((routeName)=>{
                var routeConfig = configs.find((c)=>{
                    // Check matching name AND pattern in case same screen is used at different levels in config
                    return c.screen === routeName && (0, _arrayStartsWith.arrayStartsWith)(config.segments, c.segments);
                });
                var params = routeConfig && match.groups ? Object.fromEntries(Object.entries(match.groups).map((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                    var index = Number(key.replace('param_', ''));
                    var param = routeConfig.params.find((it)=>it.index === index);
                    if ((param === null || param === void 0 ? void 0 : param.screen) === routeName && (param === null || param === void 0 ? void 0 : param.name)) {
                        return [
                            param.name,
                            value
                        ];
                    }
                    return null;
                }).filter((it)=>it != null).map((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                    var _routeConfig_parse;
                    if (value == null) {
                        return [
                            key,
                            undefined
                        ];
                    }
                    var decoded = decodeURIComponent(value);
                    var parsed = ((_routeConfig_parse = routeConfig.parse) === null || _routeConfig_parse === void 0 ? void 0 : _routeConfig_parse[key]) ? routeConfig.parse[key](decoded) : decoded;
                    return [
                        key,
                        parsed
                    ];
                })) : undefined;
                if (params && Object.keys(params).length) {
                    return {
                        name: routeName,
                        params
                    };
                }
                return {
                    name: routeName
                };
            });
            remainingPath = remainingPath.replace(match[0], '');
            return "break";
        }
    };
    var routes;
    var remainingPath = remaining;
    // Go through all configs, and see if the next path segment matches our regex
    for (var config of configs){
        var _ret = _loop(config);
        if (_ret === "break") break;
    }
    return {
        routes,
        remainingPath
    };
};
var createNormalizedConfigs = (screen, routeConfig, initials, paths, parentScreens, routeNames)=>{
    var configs = [];
    routeNames.push(screen);
    parentScreens.push(screen);
    var config = routeConfig[screen];
    if (typeof config === 'string') {
        paths.push({
            screen,
            path: config
        });
        configs.push(createConfigItem(screen, _to_consumable_array._(routeNames), _to_consumable_array._(paths)));
    } else if (typeof config === 'object') {
        var _config_alias;
        // if an object is specified as the value (e.g. Foo: { ... }),
        // it can have `path` property and
        // it could have `screens` prop which has nested configs
        if (typeof config.path === 'string') {
            var _configs;
            if (config.exact && config.path == null) {
                throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \`path: ''\`.`);
            }
            // We should add alias configs after the main config
            // So unless they are more specific, main config will be matched first
            var aliasConfigs = [];
            if (config.alias) {
                for (var alias of config.alias){
                    if (typeof alias === 'string') {
                        aliasConfigs.push(createConfigItem(screen, _to_consumable_array._(routeNames), _to_consumable_array._(paths).concat([
                            {
                                screen,
                                path: alias
                            }
                        ]), config.parse));
                    } else if (typeof alias === 'object') {
                        aliasConfigs.push(createConfigItem(screen, _to_consumable_array._(routeNames), alias.exact ? [
                            {
                                screen,
                                path: alias.path
                            }
                        ] : _to_consumable_array._(paths).concat([
                            {
                                screen,
                                path: alias.path
                            }
                        ]), alias.parse));
                    }
                }
            }
            if (config.exact) {
                // If it's an exact path, we don't need to keep track of the parent screens
                // So we can clear it
                paths.length = 0;
            }
            paths.push({
                screen,
                path: config.path
            });
            configs.push(createConfigItem(screen, _to_consumable_array._(routeNames), _to_consumable_array._(paths), config.parse));
            (_configs = configs).push.apply(_configs, _to_consumable_array._(aliasConfigs));
        }
        if (typeof config !== 'string' && typeof config.path !== 'string' && ((_config_alias = config.alias) === null || _config_alias === void 0 ? void 0 : _config_alias.length)) {
            throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`);
        }
        if (config.screens) {
            // property `initialRouteName` without `screens` has no purpose
            if (config.initialRouteName) {
                initials.push({
                    initialRouteName: config.initialRouteName,
                    parentScreens
                });
            }
            Object.keys(config.screens).forEach((nestedConfig)=>{
                var _configs;
                var result = createNormalizedConfigs(nestedConfig, config.screens, initials, _to_consumable_array._(paths), _to_consumable_array._(parentScreens), routeNames);
                (_configs = configs).push.apply(_configs, _to_consumable_array._(result));
            });
        }
    }
    routeNames.pop();
    return configs;
};
var createConfigItem = (screen, routeNames, paths, parse)=>{
    var _loop = function(ref) {
        var _$screen = ref.screen, path = ref.path;
        var _parts;
        (_parts = parts).push.apply(_parts, _to_consumable_array._((0, _getPatternParts.getPatternParts)(path).map((part)=>_object_spread_props._(_object_spread._({}, part), {
                screen: _$screen
            }))));
    };
    var parts = [];
    // Parse the path string into parts for easier matching
    for (var ref of paths)_loop(ref);
    var regex = parts.length ? new RegExp(`^(${parts.map((it, i)=>{
        if (it.param) {
            var reg = it.regex || '[^/]+';
            return `(((?<param_${i}>${reg})\\/)${it.optional ? '?' : ''})`;
        }
        return `${it.segment === '*' ? '.*' : (0, _escapestringregexp.default)(it.segment)}\\/`;
    }).join('')})$`) : undefined;
    var segments = parts.map((it)=>it.segment);
    var params = parts.map((it, i)=>it.param ? {
            index: i,
            screen: it.screen,
            name: it.param
        } : null).filter((it)=>it != null);
    return {
        screen,
        regex,
        segments,
        params,
        routeNames,
        parse
    };
};
var findParseConfigForRoute = (routeName, flatConfig)=>{
    for (var config of flatConfig){
        if (routeName === config.routeNames[config.routeNames.length - 1]) {
            return config.parse;
        }
    }
    return undefined;
};
// Try to find an initial route connected with the one passed
var findInitialRoute = (routeName, parentScreens, initialRoutes)=>{
    for (var config of initialRoutes){
        if (parentScreens.length === config.parentScreens.length) {
            var sameParents = true;
            for(var i = 0; i < parentScreens.length; i++){
                if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {
                    sameParents = false;
                    break;
                }
            }
            if (sameParents) {
                return routeName !== config.initialRouteName ? config.initialRouteName : undefined;
            }
        }
    }
    return undefined;
};
// returns state object with values depending on whether
// it is the end of state and if there is initialRoute for this level
var createStateObject = (initialRoute, route, isEmpty)=>{
    if (isEmpty) {
        if (initialRoute) {
            return {
                index: 1,
                routes: [
                    {
                        name: initialRoute
                    },
                    route
                ]
            };
        } else {
            return {
                routes: [
                    route
                ]
            };
        }
    } else {
        if (initialRoute) {
            return {
                index: 1,
                routes: [
                    {
                        name: initialRoute
                    },
                    _object_spread_props._(_object_spread._({}, route), {
                        state: {
                            routes: []
                        }
                    })
                ]
            };
        } else {
            return {
                routes: [
                    _object_spread_props._(_object_spread._({}, route), {
                        state: {
                            routes: []
                        }
                    })
                ]
            };
        }
    }
};
var createNestedStateObject = (path, routes, initialRoutes, flatConfig)=>{
    var route = routes.shift();
    var parentScreens = [];
    var initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
    parentScreens.push(route.name);
    var state = createStateObject(initialRoute, route, routes.length === 0);
    if (routes.length > 0) {
        var nestedState = state;
        while(route = routes.shift()){
            initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
            var nestedStateIndex = nestedState.index || nestedState.routes.length - 1;
            nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);
            if (routes.length > 0) {
                nestedState = nestedState.routes[nestedStateIndex].state;
            }
            parentScreens.push(route.name);
        }
    }
    route = (0, _findFocusedRoute.findFocusedRoute)(state);
    route.path = path.replace(/\/$/, '');
    var params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);
    if (params) {
        route.params = _object_spread._({}, route.params, params);
    }
    return state;
};
var parseQueryParams = (path, parseConfig)=>{
    var query = path.split('?')[1];
    var params = _querystring.parse(query);
    if (parseConfig) {
        Object.keys(params).forEach((name)=>{
            if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {
                params[name] = parseConfig[name](params[name]);
            }
        });
    }
    return Object.keys(params).length ? params : undefined;
}; //# sourceMappingURL=getStateFromPath.js.map


}),
78348: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get BaseNavigationContainer () {
        return _BaseNavigationContainer.BaseNavigationContainer;
    },
    get CurrentRenderContext () {
        return _CurrentRenderContext.CurrentRenderContext;
    },
    get NavigationContainerRefContext () {
        return _NavigationContainerRefContext.NavigationContainerRefContext;
    },
    get NavigationContext () {
        return _NavigationContext.NavigationContext;
    },
    get NavigationHelpersContext () {
        return _NavigationHelpersContext.NavigationHelpersContext;
    },
    get NavigationIndependentTree () {
        return _NavigationIndependentTree.NavigationIndependentTree;
    },
    get NavigationRouteContext () {
        return _NavigationRouteContext.NavigationRouteContext;
    },
    get PreventRemoveContext () {
        return _PreventRemoveContext.PreventRemoveContext;
    },
    get PreventRemoveProvider () {
        return _PreventRemoveProvider.PreventRemoveProvider;
    },
    get ThemeContext () {
        return _ThemeContext.ThemeContext;
    },
    get ThemeProvider () {
        return _ThemeProvider.ThemeProvider;
    },
    get createComponentForStaticNavigation () {
        return _StaticNavigation.createComponentForStaticNavigation;
    },
    get createNavigationContainerRef () {
        return _createNavigationContainerRef.createNavigationContainerRef;
    },
    get createNavigatorFactory () {
        return _createNavigatorFactory.createNavigatorFactory;
    },
    get createPathConfigForStaticNavigation () {
        return _StaticNavigation.createPathConfigForStaticNavigation;
    },
    get findFocusedRoute () {
        return _findFocusedRoute.findFocusedRoute;
    },
    get getActionFromState () {
        return _getActionFromState.getActionFromState;
    },
    get getFocusedRouteNameFromRoute () {
        return _getFocusedRouteNameFromRoute.getFocusedRouteNameFromRoute;
    },
    get getPathFromState () {
        return _getPathFromState.getPathFromState;
    },
    get getStateFromPath () {
        return _getStateFromPath.getStateFromPath;
    },
    get useFocusEffect () {
        return _useFocusEffect.useFocusEffect;
    },
    get useIsFocused () {
        return _useIsFocused.useIsFocused;
    },
    get useNavigation () {
        return _useNavigation.useNavigation;
    },
    get useNavigationBuilder () {
        return _useNavigationBuilder.useNavigationBuilder;
    },
    get useNavigationContainerRef () {
        return _useNavigationContainerRef.useNavigationContainerRef;
    },
    get useNavigationIndependentTree () {
        return _useNavigationIndependentTree.useNavigationIndependentTree;
    },
    get useNavigationState () {
        return _useNavigationState.useNavigationState;
    },
    get usePreventRemove () {
        return _usePreventRemove.usePreventRemove;
    },
    get usePreventRemoveContext () {
        return _usePreventRemoveContext.usePreventRemoveContext;
    },
    get useRoute () {
        return _useRoute.useRoute;
    },
    get useStateForPath () {
        return _useStateForPath.useStateForPath;
    },
    get useTheme () {
        return _useTheme.useTheme;
    },
    get validatePathConfig () {
        return _validatePathConfig.validatePathConfig;
    }
});
var _export_star = __webpack_require__(4084);
var _BaseNavigationContainer = __webpack_require__(16391);
var _createNavigationContainerRef = __webpack_require__(52249);
var _createNavigatorFactory = __webpack_require__(72591);
var _CurrentRenderContext = __webpack_require__(91650);
var _findFocusedRoute = __webpack_require__(86363);
var _getActionFromState = __webpack_require__(35808);
var _getFocusedRouteNameFromRoute = __webpack_require__(31970);
var _getPathFromState = __webpack_require__(73099);
var _getStateFromPath = __webpack_require__(99682);
var _NavigationContainerRefContext = __webpack_require__(82435);
var _NavigationContext = __webpack_require__(10776);
var _NavigationHelpersContext = __webpack_require__(92177);
var _NavigationIndependentTree = __webpack_require__(29592);
var _NavigationRouteContext = __webpack_require__(39928);
var _PreventRemoveContext = __webpack_require__(43346);
var _PreventRemoveProvider = __webpack_require__(62053);
var _StaticNavigation = __webpack_require__(39866);
var _ThemeContext = __webpack_require__(35322);
var _ThemeProvider = __webpack_require__(46830);
var _useTheme = __webpack_require__(22629);
_export_star._(__webpack_require__(77808), exports);
var _useFocusEffect = __webpack_require__(77450);
var _useIsFocused = __webpack_require__(89179);
var _useNavigation = __webpack_require__(27316);
var _useNavigationBuilder = __webpack_require__(45105);
var _useNavigationContainerRef = __webpack_require__(48283);
var _useNavigationIndependentTree = __webpack_require__(11476);
var _useNavigationState = __webpack_require__(84827);
var _usePreventRemove = __webpack_require__(91191);
var _usePreventRemoveContext = __webpack_require__(88381);
var _useRoute = __webpack_require__(30692);
var _useStateForPath = __webpack_require__(96576);
var _validatePathConfig = __webpack_require__(33434);
_export_star._(__webpack_require__(93675), exports);
 //# sourceMappingURL=index.js.map


}),
3311: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "isArrayEqual", ({
    enumerable: true,
    get: function() {
        return isArrayEqual;
    }
}));
function isArrayEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (a.length !== b.length) {
        return false;
    }
    return a.every((it, index)=>it === b[index]);
} //# sourceMappingURL=isArrayEqual.js.map


}),
63950: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "isRecordEqual", ({
    enumerable: true,
    get: function() {
        return isRecordEqual;
    }
}));
function isRecordEqual(a, b) {
    if (a === b) {
        return true;
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
        return false;
    }
    return aKeys.every((key)=>a[key] === b[key]);
} //# sourceMappingURL=isRecordEqual.js.map


}),
35322: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "ThemeContext", ({
    enumerable: true,
    get: function() {
        return ThemeContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var ThemeContext = /*#__PURE__*/ _react.createContext(undefined);
ThemeContext.displayName = 'ThemeContext'; //# sourceMappingURL=ThemeContext.js.map


}),
46830: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "ThemeProvider", ({
    enumerable: true,
    get: function() {
        return ThemeProvider;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _ThemeContext = __webpack_require__(35322);
var _jsxruntime = __webpack_require__(70095);
function ThemeProvider(ref) {
    var value = ref.value, children = ref.children;
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_ThemeContext.ThemeContext.Provider, {
        value: value,
        children: children
    });
} //# sourceMappingURL=ThemeProvider.js.map


}),
22629: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useTheme", ({
    enumerable: true,
    get: function() {
        return useTheme;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _ThemeContext = __webpack_require__(35322);
function useTheme() {
    var theme = _react.useContext(_ThemeContext.ThemeContext);
    if (theme == null) {
        throw new Error("Couldn't find a theme. Is your component inside NavigationContainer or does it have a theme?");
    }
    return theme;
} //# sourceMappingURL=useTheme.js.map


}),
77808: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "PrivateValueStore", ({
    enumerable: true,
    get: function() {
        return PrivateValueStore;
    }
}));
var _class_call_check = __webpack_require__(8864);
var PrivateValueStore = function PrivateValueStore() {
    _class_call_check._(this, PrivateValueStore);
} //# sourceMappingURL=types.js.map
;


}),
68905: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useChildListeners", ({
    enumerable: true,
    get: function() {
        return useChildListeners;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
function useChildListeners() {
    var _React_useRef = _react.useRef({
        action: [],
        focus: []
    }), listeners = _React_useRef.current;
    var addListener = _react.useCallback((type, listener)=>{
        listeners[type].push(listener);
        var removed = false;
        return ()=>{
            var index = listeners[type].indexOf(listener);
            if (!removed && index > -1) {
                removed = true;
                listeners[type].splice(index, 1);
            }
        };
    }, [
        listeners
    ]);
    return {
        listeners,
        addListener
    };
} //# sourceMappingURL=useChildListeners.js.map


}),
18391: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useClientLayoutEffect", ({
    enumerable: true,
    get: function() {
        return useClientLayoutEffect;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var useClientLayoutEffect = typeof document !== 'undefined' || typeof navigator !== 'undefined' && navigator.product === 'ReactNative' ? _react.useLayoutEffect : _react.useEffect; //# sourceMappingURL=useClientLayoutEffect.js.map


}),
41524: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useComponent", ({
    enumerable: true,
    get: function() {
        return useComponent;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _jsxruntime = __webpack_require__(70095);
var NavigationContent = (ref)=>{
    var render = ref.render, children = ref.children;
    return render(children);
};
function useComponent(render) {
    var renderRef = _react.useRef(render);
    // Normally refs shouldn't be mutated in render
    // But we return a component which will be rendered
    // So it's just for immediate consumption
    renderRef.current = render;
    _react.useEffect(()=>{
        renderRef.current = null;
    });
    return _react.useRef((ref)=>{
        var children = ref.children;
        var _$render = renderRef.current;
        if (_$render === null) {
            throw new Error('The returned component must be rendered in the same render phase as the hook.');
        }
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(NavigationContent, {
            render: _$render,
            children: children
        });
    }).current;
} //# sourceMappingURL=useComponent.js.map


}),
97786: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useCurrentRender", ({
    enumerable: true,
    get: function() {
        return useCurrentRender;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _CurrentRenderContext = __webpack_require__(91650);
function useCurrentRender(ref) {
    var state = ref.state, navigation = ref.navigation, descriptors = ref.descriptors;
    var current = _react.useContext(_CurrentRenderContext.CurrentRenderContext);
    if (current && navigation.isFocused()) {
        current.options = descriptors[state.routes[state.index].key].options;
    }
} //# sourceMappingURL=useCurrentRender.js.map


}),
25011: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useDescriptors", ({
    enumerable: true,
    get: function() {
        return useDescriptors;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _object_without_properties = __webpack_require__(86136);
var _sliced_to_array = __webpack_require__(78474);
var _to_consumable_array = __webpack_require__(92716);
var _to_property_key = __webpack_require__(46306);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationBuilderContext = __webpack_require__(4323);
var _NavigationContext = __webpack_require__(10776);
var _NavigationRouteContext = __webpack_require__(39928);
var _SceneView = __webpack_require__(26296);
var _ThemeContext = __webpack_require__(35322);
var _useNavigationCache = __webpack_require__(22565);
var _useRouteCache = __webpack_require__(62289);
var _jsxruntime = __webpack_require__(70095);
function useDescriptors(ref) {
    var state = ref.state, screens = ref.screens, navigation = ref.navigation, screenOptions = ref.screenOptions, screenLayout = ref.screenLayout, onAction = ref.onAction, getState = ref.getState, setState = ref.setState, addListener = ref.addListener, addKeyedListener = ref.addKeyedListener, onRouteFocus = ref.onRouteFocus, router = ref.router, emitter = ref.emitter;
    var theme = _react.useContext(_ThemeContext.ThemeContext);
    var _React_useState = _sliced_to_array._(_react.useState({}), 2), options = _React_useState[0], setOptions = _React_useState[1];
    var _React_useContext = _react.useContext(_NavigationBuilderContext.NavigationBuilderContext), onDispatchAction = _React_useContext.onDispatchAction, onOptionsChange = _React_useContext.onOptionsChange, scheduleUpdate = _React_useContext.scheduleUpdate, flushUpdates = _React_useContext.flushUpdates, stackRef = _React_useContext.stackRef;
    var context = _react.useMemo(()=>({
            navigation,
            onAction,
            addListener,
            addKeyedListener,
            onRouteFocus,
            onDispatchAction,
            onOptionsChange,
            scheduleUpdate,
            flushUpdates,
            stackRef
        }), [
        navigation,
        onAction,
        addListener,
        addKeyedListener,
        onRouteFocus,
        onDispatchAction,
        onOptionsChange,
        scheduleUpdate,
        flushUpdates,
        stackRef
    ]);
    var _useNavigationCache1 = (0, _useNavigationCache.useNavigationCache)({
        state,
        getState,
        navigation,
        setOptions,
        router,
        emitter
    }), base = _useNavigationCache1.base, navigations = _useNavigationCache1.navigations;
    var routes = (0, _useRouteCache.useRouteCache)(state.routes);
    var getOptions = (route, navigation, overrides)=>{
        var config = screens[route.name];
        var screen = config.props;
        var optionsList = [
            // The default `screenOptions` passed to the navigator
            screenOptions
        ].concat(// The `screenOptions` props passed to `Group` elements
        _to_consumable_array._(config.options ? config.options.filter(Boolean) : []), [
            // The `options` prop passed to `Screen` elements,
            screen.options,
            // The options set via `navigation.setOptions`
            overrides
        ]);
        return optionsList.reduce((acc, curr)=>Object.assign(acc, // @ts-expect-error: we check for function but TS still complains
            typeof curr !== 'function' ? curr : curr({
                route,
                navigation,
                theme
            })), {});
    };
    var render = (route, navigation, customOptions, routeState)=>{
        var config = screens[route.name];
        var screen = config.props;
        var clearOptions = ()=>setOptions((o)=>{
                if (route.key in o) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    var _route_key = route.key, _ = o[_route_key], rest = _object_without_properties._(o, [
                        _route_key
                    ].map(_to_property_key._));
                    return rest;
                }
                return o;
            });
        var layout = // The `layout` prop passed to `Screen` elements,
        screen.layout ?? // The `screenLayout` props passed to `Group` elements
        config.layout ?? // The default `screenLayout` passed to the navigator
        screenLayout;
        var element = /*#__PURE__*/ (0, _jsxruntime.jsx)(_SceneView.SceneView, {
            navigation: navigation,
            route: route,
            screen: screen,
            routeState: routeState,
            getState: getState,
            setState: setState,
            options: customOptions,
            clearOptions: clearOptions
        });
        if (layout != null) {
            element = layout({
                route,
                navigation,
                options: customOptions,
                // @ts-expect-error: in practice `theme` will be defined
                theme,
                children: element
            });
        }
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationBuilderContext.NavigationBuilderContext.Provider, {
            value: context,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationContext.NavigationContext.Provider, {
                value: navigation,
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationRouteContext.NavigationRouteContext.Provider, {
                    value: route,
                    children: element
                })
            })
        }, route.key);
    };
    var descriptors = routes.reduce((acc, route, i)=>{
        var navigation = navigations[route.key];
        var customOptions = getOptions(route, navigation, options[route.key]);
        var element = render(route, navigation, customOptions, state.routes[i].state);
        acc[route.key] = {
            route,
            // @ts-expect-error: it's missing action helpers, fix later
            navigation,
            render () {
                return element;
            },
            options: customOptions
        };
        return acc;
    }, {});
    /**
   * Create a descriptor object for a route.
   *
   * @param route Route object for which the descriptor should be created
   * @param placeholder Whether the descriptor should be a placeholder, e.g. for a route not yet in the state
   * @returns Descriptor object
   */ var describe = (route, placeholder)=>{
        if (!placeholder) {
            if (!(route.key in descriptors)) {
                throw new Error(`Couldn't find a route with the key ${route.key}.`);
            }
            return descriptors[route.key];
        }
        var navigation = base;
        var customOptions = getOptions(route, navigation, {});
        var element = render(route, navigation, customOptions, undefined);
        return {
            route,
            navigation,
            render () {
                return element;
            },
            options: customOptions
        };
    };
    return {
        describe,
        descriptors
    };
} //# sourceMappingURL=useDescriptors.js.map


}),
15813: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useEventEmitter", ({
    enumerable: true,
    get: function() {
        return useEventEmitter;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _to_consumable_array = __webpack_require__(92716);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
function useEventEmitter(listen) {
    var listenRef = _react.useRef(listen);
    _react.useEffect(()=>{
        listenRef.current = listen;
    });
    var listeners = _react.useRef(Object.create(null));
    var create = _react.useCallback((target)=>{
        var removeListener = (type, callback)=>{
            var callbacks = listeners.current[type] ? listeners.current[type][target] : undefined;
            if (!callbacks) {
                return;
            }
            var index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        };
        var addListener = (type, callback)=>{
            listeners.current[type] = listeners.current[type] || {};
            listeners.current[type][target] = listeners.current[type][target] || [];
            listeners.current[type][target].push(callback);
            var removed = false;
            return ()=>{
                // Prevent removing other listeners when unsubscribing same listener multiple times
                if (!removed) {
                    removed = true;
                    removeListener(type, callback);
                }
            };
        };
        return {
            addListener,
            removeListener
        };
    }, []);
    var emit = _react.useCallback((ref)=>{
        var type = ref.type, data = ref.data, target = ref.target, canPreventDefault = ref.canPreventDefault;
        var _instance;
        var _items_target, _listenRef_current;
        var items = listeners.current[type] || {};
        // Copy the current list of callbacks in case they are mutated during execution
        var callbacks = target !== undefined ? (_items_target = items[target]) === null || _items_target === void 0 ? void 0 : _items_target.slice() : (_instance = []).concat.apply(_instance, _to_consumable_array._(Object.keys(items).map((t)=>items[t]))).filter((cb, i, self)=>self.lastIndexOf(cb) === i);
        var event = {
            get type () {
                return type;
            }
        };
        if (target !== undefined) {
            Object.defineProperty(event, 'target', {
                enumerable: true,
                get () {
                    return target;
                }
            });
        }
        if (data !== undefined) {
            Object.defineProperty(event, 'data', {
                enumerable: true,
                get () {
                    return data;
                }
            });
        }
        if (canPreventDefault) {
            var defaultPrevented = false;
            Object.defineProperties(event, {
                defaultPrevented: {
                    enumerable: true,
                    get () {
                        return defaultPrevented;
                    }
                },
                preventDefault: {
                    enumerable: true,
                    value () {
                        defaultPrevented = true;
                    }
                }
            });
        }
        (_listenRef_current = listenRef.current) === null || _listenRef_current === void 0 ? void 0 : _listenRef_current.call(listenRef, event);
        callbacks === null || callbacks === void 0 ? void 0 : callbacks.forEach((cb)=>cb(event));
        return event;
    }, []);
    return _react.useMemo(()=>({
            create,
            emit
        }), [
        create,
        emit
    ]);
} //# sourceMappingURL=useEventEmitter.js.map


}),
77450: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useFocusEffect", ({
    enumerable: true,
    get: function() {
        return useFocusEffect;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _useNavigation = __webpack_require__(27316);
function useFocusEffect(effect) {
    var navigation = (0, _useNavigation.useNavigation)();
    // eslint-disable-next-line prefer-rest-params
    if (arguments[1] !== undefined) {
        var message = "You passed a second argument to 'useFocusEffect', but it only accepts one argument. " + "If you want to pass a dependency array, you can use 'React.useCallback':\n\n" + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    // Your code here\n' + '  }, [depA, depB])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
        console.error(message);
    }
    _react.useEffect(()=>{
        var isFocused = false;
        var cleanup;
        var callback = ()=>{
            var destroy = effect();
            if (destroy === undefined || typeof destroy === 'function') {
                return destroy;
            }
            if (false) { var message }
        };
        // We need to run the effect on initial render/dep changes if the screen is focused
        if (navigation.isFocused()) {
            cleanup = callback();
            isFocused = true;
        }
        var unsubscribeFocus = navigation.addListener('focus', ()=>{
            // If callback was already called for focus, avoid calling it again
            // The focus event may also fire on initial render, so we guard against running the effect twice
            if (isFocused) {
                return;
            }
            if (cleanup !== undefined) {
                cleanup();
            }
            cleanup = callback();
            isFocused = true;
        });
        var unsubscribeBlur = navigation.addListener('blur', ()=>{
            if (cleanup !== undefined) {
                cleanup();
            }
            cleanup = undefined;
            isFocused = false;
        });
        return ()=>{
            if (cleanup !== undefined) {
                cleanup();
            }
            unsubscribeFocus();
            unsubscribeBlur();
        };
    }, [
        effect,
        navigation
    ]);
} //# sourceMappingURL=useFocusEffect.js.map


}),
97966: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useFocusEvents", ({
    enumerable: true,
    get: function() {
        return useFocusEvents;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationContext = __webpack_require__(10776);
function useFocusEvents(ref) {
    var state = ref.state, emitter = ref.emitter;
    var navigation = _react.useContext(_NavigationContext.NavigationContext);
    var lastFocusedKeyRef = _react.useRef(undefined);
    var currentFocusedKey = state.routes[state.index].key;
    // When the parent screen changes its focus state, we also need to change child's focus
    // Coz the child screen can't be focused if the parent screen is out of focus
    _react.useEffect(()=>navigation === null || navigation === void 0 ? void 0 : navigation.addListener('focus', ()=>{
            lastFocusedKeyRef.current = currentFocusedKey;
            emitter.emit({
                type: 'focus',
                target: currentFocusedKey
            });
        }), [
        currentFocusedKey,
        emitter,
        navigation
    ]);
    _react.useEffect(()=>navigation === null || navigation === void 0 ? void 0 : navigation.addListener('blur', ()=>{
            lastFocusedKeyRef.current = undefined;
            emitter.emit({
                type: 'blur',
                target: currentFocusedKey
            });
        }), [
        currentFocusedKey,
        emitter,
        navigation
    ]);
    _react.useEffect(()=>{
        var lastFocusedKey = lastFocusedKeyRef.current;
        lastFocusedKeyRef.current = currentFocusedKey;
        // We wouldn't have `lastFocusedKey` on initial mount
        // Fire focus event for the current route on mount if there's no parent navigator
        if (lastFocusedKey === undefined && !navigation) {
            emitter.emit({
                type: 'focus',
                target: currentFocusedKey
            });
        }
        // We should only emit events when the focused key changed and navigator is focused
        // When navigator is not focused, screens inside shouldn't receive focused status either
        if (lastFocusedKey === currentFocusedKey || !(navigation ? navigation.isFocused() : true)) {
            return;
        }
        if (lastFocusedKey === undefined) {
            // Only fire events after initial mount
            return;
        }
        emitter.emit({
            type: 'blur',
            target: lastFocusedKey
        });
        emitter.emit({
            type: 'focus',
            target: currentFocusedKey
        });
    }, [
        currentFocusedKey,
        emitter,
        navigation
    ]);
} //# sourceMappingURL=useFocusEvents.js.map


}),
81558: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useFocusedListenersChildrenAdapter", ({
    enumerable: true,
    get: function() {
        return useFocusedListenersChildrenAdapter;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationBuilderContext = __webpack_require__(4323);
function useFocusedListenersChildrenAdapter(ref) {
    var navigation = ref.navigation, focusedListeners = ref.focusedListeners;
    var addListener = _react.useContext(_NavigationBuilderContext.NavigationBuilderContext).addListener;
    var listener = _react.useCallback((callback)=>{
        if (navigation.isFocused()) {
            for (var listener of focusedListeners){
                var _listener = listener(callback), handled = _listener.handled, result = _listener.result;
                if (handled) {
                    return {
                        handled,
                        result
                    };
                }
            }
            return {
                handled: true,
                result: callback(navigation)
            };
        } else {
            return {
                handled: false,
                result: null
            };
        }
    }, [
        focusedListeners,
        navigation
    ]);
    _react.useEffect(()=>addListener === null || addListener === void 0 ? void 0 : addListener('focus', listener), [
        addListener,
        listener
    ]);
} //# sourceMappingURL=useFocusedListenersChildrenAdapter.js.map


}),
89179: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useIsFocused", ({
    enumerable: true,
    get: function() {
        return useIsFocused;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _useNavigation = __webpack_require__(27316);
function useIsFocused() {
    var navigation = (0, _useNavigation.useNavigation)();
    var subscribe = _react.useCallback((callback)=>{
        var unsubscribeFocus = navigation.addListener('focus', callback);
        var unsubscribeBlur = navigation.addListener('blur', callback);
        return ()=>{
            unsubscribeFocus();
            unsubscribeBlur();
        };
    }, [
        navigation
    ]);
    var value = _react.useSyncExternalStore(subscribe, navigation.isFocused, navigation.isFocused);
    return value;
} //# sourceMappingURL=useIsFocused.js.map


}),
26112: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useKeyedChildListeners", ({
    enumerable: true,
    get: function() {
        return useKeyedChildListeners;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
function useKeyedChildListeners() {
    var _React_useRef = _react.useRef(Object.assign(Object.create(null), {
        getState: {},
        beforeRemove: {}
    })), keyedListeners = _React_useRef.current;
    var addKeyedListener = _react.useCallback((type, key, listener)=>{
        // @ts-expect-error: according to ref stated above you can use `key` to index type
        keyedListeners[type][key] = listener;
        return ()=>{
            // @ts-expect-error: according to ref stated above you can use `key` to index type
            keyedListeners[type][key] = undefined;
        };
    }, [
        keyedListeners
    ]);
    return {
        keyedListeners,
        addKeyedListener
    };
} //# sourceMappingURL=useKeyedChildListeners.js.map


}),
88876: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useLazyValue", ({
    enumerable: true,
    get: function() {
        return useLazyValue;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
function useLazyValue(create) {
    var lazyRef = _react.useRef(undefined);
    if (lazyRef.current === undefined) {
        lazyRef.current = create();
    }
    return lazyRef.current;
} //# sourceMappingURL=useLazyValue.js.map


}),
27316: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useNavigation", ({
    enumerable: true,
    get: function() {
        return useNavigation;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationContainerRefContext = __webpack_require__(82435);
var _NavigationContext = __webpack_require__(10776);
function useNavigation() {
    var root = _react.useContext(_NavigationContainerRefContext.NavigationContainerRefContext);
    var navigation = _react.useContext(_NavigationContext.NavigationContext);
    if (navigation === undefined && root === undefined) {
        throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    // FIXME: Figure out a better way to do this
    return navigation ?? root;
} //# sourceMappingURL=useNavigation.js.map


}),
45105: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useNavigationBuilder", ({
    enumerable: true,
    get: function() {
        return useNavigationBuilder;
    }
}));
var _interop_require_default = __webpack_require__(66705);
var _interop_require_wildcard = __webpack_require__(83610);
var _object_spread = __webpack_require__(36192);
var _object_without_properties = __webpack_require__(86136);
var _sliced_to_array = __webpack_require__(78474);
var _to_consumable_array = __webpack_require__(92716);
var _routers = __webpack_require__(93675);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _reactis = __webpack_require__(37899);
var _uselatestcallback = /*#__PURE__*/ _interop_require_default._(__webpack_require__(694));
var _deepFreeze = __webpack_require__(5552);
var _Group = __webpack_require__(44052);
var _isArrayEqual = __webpack_require__(3311);
var _isRecordEqual = __webpack_require__(63950);
var _NavigationHelpersContext = __webpack_require__(92177);
var _NavigationRouteContext = __webpack_require__(39928);
var _NavigationStateContext = __webpack_require__(16558);
var _PreventRemoveProvider = __webpack_require__(62053);
var _Screen = __webpack_require__(38304);
var _types = __webpack_require__(77808);
var _useChildListeners = __webpack_require__(68905);
var _useClientLayoutEffect = __webpack_require__(18391);
var _useComponent = __webpack_require__(41524);
var _useCurrentRender = __webpack_require__(97786);
var _useDescriptors = __webpack_require__(25011);
var _useEventEmitter = __webpack_require__(15813);
var _useFocusedListenersChildrenAdapter = __webpack_require__(81558);
var _useFocusEvents = __webpack_require__(97966);
var _useKeyedChildListeners = __webpack_require__(26112);
var _useLazyValue = __webpack_require__(88876);
var _useNavigationHelpers = __webpack_require__(36491);
var _useNavigationState = __webpack_require__(84827);
var _useOnAction = __webpack_require__(44406);
var _useOnGetState = __webpack_require__(62201);
var _useOnRouteFocus = __webpack_require__(79969);
var _useRegisterNavigator = __webpack_require__(30247);
var _useScheduleUpdate = __webpack_require__(30819);
var _jsxruntime = __webpack_require__(70095);
_types.PrivateValueStore;
var isScreen = (child)=>{
    return child.type === _Screen.Screen;
};
var isGroup = (child)=>{
    return child.type === _react.Fragment || child.type === _Group.Group;
};
var isValidKey = (key)=>key === undefined || typeof key === 'string' && key !== '';
/**
 * Extract route config object from React children elements.
 *
 * @param children React Elements to extract the config from.
 */ var getRouteConfigsFromChildren = (children, groupKey, groupOptions, groupLayout)=>{
    var configs = _react.Children.toArray(children).reduce((acc, child)=>{
        var _child_type, _child_props;
        if (/*#__PURE__*/ _react.isValidElement(child)) {
            if (isScreen(child)) {
                // We can only extract the config from `Screen` elements
                // If something else was rendered, it's probably a bug
                if (typeof child.props !== 'object' || child.props === null) {
                    throw new Error(`Got an invalid element for screen.`);
                }
                if (typeof child.props.name !== 'string' || child.props.name === '') {
                    throw new Error(`Got an invalid name (${JSON.stringify(child.props.name)}) for the screen. It must be a non-empty string.`);
                }
                if (child.props.navigationKey !== undefined && (typeof child.props.navigationKey !== 'string' || child.props.navigationKey === '')) {
                    throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the screen '${child.props.name}'. It must be a non-empty string or 'undefined'.`);
                }
                acc.push({
                    keys: [
                        groupKey,
                        child.props.navigationKey
                    ],
                    options: groupOptions,
                    layout: groupLayout,
                    props: child.props
                });
                return acc;
            }
            if (isGroup(child)) {
                var // When we encounter a fragment or group, we need to dive into its children to extract the configs
                // This is handy to conditionally define a group of screens
                _acc;
                if (!isValidKey(child.props.navigationKey)) {
                    throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the group. It must be a non-empty string or 'undefined'.`);
                }
                (_acc = acc).push.apply(_acc, _to_consumable_array._(getRouteConfigsFromChildren(child.props.children, child.props.navigationKey, // FIXME
                // @ts-expect-error: add validation
                child.type !== _Group.Group ? groupOptions : groupOptions != null ? _to_consumable_array._(groupOptions).concat([
                    child.props.screenOptions
                ]) : [
                    child.props.screenOptions
                ], typeof child.props.screenLayout === 'function' ? child.props.screenLayout : groupLayout)));
                return acc;
            }
        }
        throw new Error(`A navigator can only contain 'Screen', 'Group' or 'React.Fragment' as its direct children (found ${/*#__PURE__*/ _react.isValidElement(child) ? `'${typeof child.type === 'string' ? child.type : (_child_type = child.type) === null || _child_type === void 0 ? void 0 : _child_type.name}'${child.props != null && typeof child.props === 'object' && 'name' in child.props && ((_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props.name) ? ` for the screen '${child.props.name}'` : ''}` : typeof child === 'object' ? JSON.stringify(child) : `'${String(child)}'`}). To render this component in the navigator, pass it in the 'component' prop to 'Screen'.`);
    }, []);
    if (false) {}
    return configs;
};
function useNavigationBuilder(createRouter, options) {
    var navigatorKey = (0, _useRegisterNavigator.useRegisterNavigator)();
    var route = _react.useContext(_NavigationRouteContext.NavigationRouteContext);
    var children = options.children, layout = options.layout, screenOptions = options.screenOptions, screenLayout = options.screenLayout, screenListeners = options.screenListeners, UNSTABLE_router = options.UNSTABLE_router, rest = _object_without_properties._(options, [
        "children",
        "layout",
        "screenOptions",
        "screenLayout",
        "screenListeners",
        "UNSTABLE_router"
    ]);
    var routeConfigs = getRouteConfigsFromChildren(children);
    var router = (0, _useLazyValue.useLazyValue)(()=>{
        if (rest.initialRouteName != null && routeConfigs.every((config)=>config.props.name !== rest.initialRouteName)) {
            throw new Error(`Couldn't find a screen named '${rest.initialRouteName}' to use as 'initialRouteName'.`);
        }
        var original = createRouter(rest);
        if (UNSTABLE_router != null) {
            var overrides = UNSTABLE_router(original);
            return _object_spread._({}, original, overrides);
        }
        return original;
    });
    var screens = routeConfigs.reduce((acc, config)=>{
        if (config.props.name in acc) {
            throw new Error(`A navigator cannot contain multiple 'Screen' components with the same name (found duplicate screen named '${config.props.name}')`);
        }
        acc[config.props.name] = config;
        return acc;
    }, {});
    var routeNames = routeConfigs.map((config)=>config.props.name);
    var routeKeyList = routeNames.reduce((acc, curr)=>{
        acc[curr] = screens[curr].keys.map((key)=>key ?? '').join(':');
        return acc;
    }, {});
    var routeParamList = routeNames.reduce((acc, curr)=>{
        var initialParams = screens[curr].props.initialParams;
        acc[curr] = initialParams;
        return acc;
    }, {});
    var routeGetIdList = routeNames.reduce((acc, curr)=>Object.assign(acc, {
            [curr]: screens[curr].props.getId
        }), {});
    if (!routeNames.length) {
        throw new Error("Couldn't find any screens for the navigator. Have you defined any screens as its children?");
    }
    var isStateValid = _react.useCallback((state)=>state.type === undefined || state.type === router.type, [
        router.type
    ]);
    var isStateInitialized = _react.useCallback((state)=>state !== undefined && state.stale === false && isStateValid(state), [
        isStateValid
    ]);
    var _React_useContext = _react.useContext(_NavigationStateContext.NavigationStateContext), currentState = _React_useContext.state, getCurrentState = _React_useContext.getState, setCurrentState = _React_useContext.setState, setKey = _React_useContext.setKey, getKey = _React_useContext.getKey, getIsInitial = _React_useContext.getIsInitial;
    var stateCleanedUp = _react.useRef(false);
    var setState = (0, _uselatestcallback.default)((state)=>{
        if (stateCleanedUp.current) {
            // State might have been already cleaned up due to unmount
            // We do not want to expose API allowing to override this
            // This would lead to old data preservation on main navigator unmount
            return;
        }
        setCurrentState(state);
    });
    var _React_useMemo = _sliced_to_array._(_react.useMemo(()=>{
        var _route_params, _route_params1, _route_params2;
        var initialRouteParamList = routeNames.reduce((acc, curr)=>{
            var _route_params, _route_params1, _route_params2;
            var initialParams = screens[curr].props.initialParams;
            var initialParamsFromParams = (route === null || route === void 0 ? void 0 : (_route_params = route.params) === null || _route_params === void 0 ? void 0 : _route_params.state) == null && (route === null || route === void 0 ? void 0 : (_route_params1 = route.params) === null || _route_params1 === void 0 ? void 0 : _route_params1.initial) !== false && (route === null || route === void 0 ? void 0 : (_route_params2 = route.params) === null || _route_params2 === void 0 ? void 0 : _route_params2.screen) === curr ? route.params.params : undefined;
            acc[curr] = initialParams !== undefined || initialParamsFromParams !== undefined ? _object_spread._({}, initialParams, initialParamsFromParams) : undefined;
            return acc;
        }, {});
        // If the current state isn't initialized on first render, we initialize it
        // We also need to re-initialize it if the state passed from parent was changed (maybe due to reset)
        // Otherwise assume that the state was provided as initial state
        // So we need to rehydrate it to make it usable
        if ((currentState === undefined || !isStateValid(currentState)) && (route === null || route === void 0 ? void 0 : (_route_params = route.params) === null || _route_params === void 0 ? void 0 : _route_params.state) == null && !(typeof (route === null || route === void 0 ? void 0 : (_route_params1 = route.params) === null || _route_params1 === void 0 ? void 0 : _route_params1.screen) === 'string' && (route === null || route === void 0 ? void 0 : (_route_params2 = route.params) === null || _route_params2 === void 0 ? void 0 : _route_params2.initial) !== false)) {
            return [
                router.getInitialState({
                    routeNames,
                    routeParamList: initialRouteParamList,
                    routeGetIdList
                }),
                true
            ];
        } else {
            var _route_params3, _route_params4, _route_params5;
            var stateFromParams;
            if ((route === null || route === void 0 ? void 0 : (_route_params3 = route.params) === null || _route_params3 === void 0 ? void 0 : _route_params3.state) != null) {
                stateFromParams = route.params.state;
            } else if (typeof (route === null || route === void 0 ? void 0 : (_route_params4 = route.params) === null || _route_params4 === void 0 ? void 0 : _route_params4.screen) === 'string' && (route === null || route === void 0 ? void 0 : (_route_params5 = route.params) === null || _route_params5 === void 0 ? void 0 : _route_params5.initial) !== false) {
                stateFromParams = {
                    index: 0,
                    routes: [
                        {
                            name: route.params.screen,
                            params: route.params.params,
                            path: route.params.path
                        }
                    ]
                };
            }
            return [
                router.getRehydratedState(stateFromParams ?? currentState, {
                    routeNames,
                    routeParamList: initialRouteParamList,
                    routeGetIdList
                }),
                false
            ];
        }
    // We explicitly don't include routeNames, route.params etc. in the dep list
    // below. We want to avoid forcing a new state to be calculated in those cases
    // Instead, we handle changes to these in the nextState code below. Note
    // that some changes to routeConfigs are explicitly ignored, such as changes
    // to initialParams
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        currentState,
        router,
        isStateValid
    ]), 2), initializedState = _React_useMemo[0], isFirstStateInitialization = _React_useMemo[1];
    var previousRouteKeyListRef = _react.useRef(routeKeyList);
    _react.useEffect(()=>{
        previousRouteKeyListRef.current = routeKeyList;
    });
    var previousRouteKeyList = previousRouteKeyListRef.current;
    var state = // If the state isn't initialized, or stale, use the state we initialized instead
    // The state won't update until there's a change needed in the state we have initialized locally
    // So it'll be `undefined` or stale until the first navigation event happens
    isStateInitialized(currentState) ? currentState : initializedState;
    var nextState = state;
    if (!(0, _isArrayEqual.isArrayEqual)(state.routeNames, routeNames) || !(0, _isRecordEqual.isRecordEqual)(routeKeyList, previousRouteKeyList)) {
        // When the list of route names change, the router should handle it to remove invalid routes
        nextState = router.getStateForRouteNamesChange(state, {
            routeNames,
            routeParamList,
            routeGetIdList,
            routeKeyChanges: Object.keys(routeKeyList).filter((name)=>name in previousRouteKeyList && routeKeyList[name] !== previousRouteKeyList[name])
        });
    }
    var previousNestedParamsRef = _react.useRef(route === null || route === void 0 ? void 0 : route.params);
    _react.useEffect(()=>{
        previousNestedParamsRef.current = route === null || route === void 0 ? void 0 : route.params;
    }, [
        route === null || route === void 0 ? void 0 : route.params
    ]);
    if (route === null || route === void 0 ? void 0 : route.params) {
        var previousParams = previousNestedParamsRef.current;
        var action;
        if (typeof route.params.state === 'object' && route.params.state != null && route.params !== previousParams) {
            // If the route was updated with new state, we should reset to it
            action = _routers.CommonActions.reset(route.params.state);
        } else if (typeof route.params.screen === 'string' && (route.params.initial === false && isFirstStateInitialization || route.params !== previousParams)) {
            // If the route was updated with new screen name and/or params, we should navigate there
            action = _routers.CommonActions.navigate({
                name: route.params.screen,
                params: route.params.params,
                path: route.params.path,
                merge: route.params.merge,
                pop: route.params.pop
            });
        }
        // The update should be limited to current navigator only, so we call the router manually
        var updatedState = action ? router.getStateForAction(nextState, action, {
            routeNames,
            routeParamList,
            routeGetIdList
        }) : null;
        nextState = updatedState !== null ? router.getRehydratedState(updatedState, {
            routeNames,
            routeParamList,
            routeGetIdList
        }) : nextState;
    }
    var shouldUpdate = state !== nextState;
    (0, _useScheduleUpdate.useScheduleUpdate)(()=>{
        if (shouldUpdate) {
            // If the state needs to be updated, we'll schedule an update
            setState(nextState);
        }
    });
    // The up-to-date state will come in next render, but we don't need to wait for it
    // We can't use the outdated state since the screens have changed, which will cause error due to mismatched config
    // So we override the state object we return to use the latest state as soon as possible
    state = nextState;
    _react.useEffect(()=>{
        // In strict mode, React will double-invoke effects.
        // So we need to reset the flag if component was not unmounted
        stateCleanedUp.current = false;
        setKey(navigatorKey);
        if (!getIsInitial()) {
            // If it's not initial render, we need to update the state
            // This will make sure that our container gets notifier of state changes due to new mounts
            // This is necessary for proper screen tracking, URL updates etc.
            setState(nextState);
        }
        return ()=>{
            // We need to clean up state for this navigator on unmount
            if (getCurrentState() !== undefined && getKey() === navigatorKey) {
                setCurrentState(undefined);
                stateCleanedUp.current = true;
            }
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    // In some cases (e.g. route names change), internal state might have changed
    // But it hasn't been committed yet, so hasn't propagated to the sync external store
    // During this time, we need to return the internal state in `getState`
    // Otherwise it can result in inconsistent state during render in children
    // To avoid this, we use a ref for render phase, and immediately clear it on commit
    var stateRef = _react.useRef(state);
    stateRef.current = state;
    (0, _useClientLayoutEffect.useClientLayoutEffect)(()=>{
        stateRef.current = null;
    });
    var getState = (0, _uselatestcallback.default)(()=>{
        var currentState = getCurrentState();
        return (0, _deepFreeze.deepFreeze)(isStateInitialized(currentState) ? currentState : initializedState);
    });
    var emitter = (0, _useEventEmitter.useEventEmitter)((e)=>{
        var _instance;
        var routeNames = [];
        var route;
        if (e.target) {
            route = state.routes.find((route)=>route.key === e.target);
            if (route === null || route === void 0 ? void 0 : route.name) {
                routeNames.push(route.name);
            }
        } else {
            var _routeNames;
            route = state.routes[state.index];
            (_routeNames = routeNames).push.apply(_routeNames, _to_consumable_array._(Object.keys(screens).filter((name)=>(route === null || route === void 0 ? void 0 : route.name) === name)));
        }
        if (route == null) {
            return;
        }
        var navigation = descriptors[route.key].navigation;
        var listeners = (_instance = []).concat.apply(_instance, // Get an array of listeners for all screens + common listeners on navigator
        _to_consumable_array._([
            screenListeners
        ].concat(_to_consumable_array._(routeNames.map((name)=>{
            var listeners = screens[name].props.listeners;
            return listeners;
        }))).map((listeners)=>{
            var map = typeof listeners === 'function' ? listeners({
                route: route,
                navigation
            }) : listeners;
            return map ? Object.keys(map).filter((type)=>type === e.type).map((type)=>map === null || map === void 0 ? void 0 : map[type]) : undefined;
        })))// We don't want same listener to be called multiple times for same event
        // So we remove any duplicate functions from the array
        .filter((cb, i, self)=>cb && self.lastIndexOf(cb) === i);
        listeners.forEach((listener)=>listener === null || listener === void 0 ? void 0 : listener(e));
    });
    (0, _useFocusEvents.useFocusEvents)({
        state,
        emitter
    });
    _react.useEffect(()=>{
        emitter.emit({
            type: 'state',
            data: {
                state
            }
        });
    }, [
        emitter,
        state
    ]);
    var _useChildListeners1 = (0, _useChildListeners.useChildListeners)(), childListeners = _useChildListeners1.listeners, addListener = _useChildListeners1.addListener;
    var _useKeyedChildListeners1 = (0, _useKeyedChildListeners.useKeyedChildListeners)(), keyedListeners = _useKeyedChildListeners1.keyedListeners, addKeyedListener = _useKeyedChildListeners1.addKeyedListener;
    var onAction = (0, _useOnAction.useOnAction)({
        router,
        getState,
        setState,
        key: route === null || route === void 0 ? void 0 : route.key,
        actionListeners: childListeners.action,
        beforeRemoveListeners: keyedListeners.beforeRemove,
        routerConfigOptions: {
            routeNames,
            routeParamList,
            routeGetIdList
        },
        emitter
    });
    var onRouteFocus = (0, _useOnRouteFocus.useOnRouteFocus)({
        router,
        key: route === null || route === void 0 ? void 0 : route.key,
        getState,
        setState
    });
    var navigation = (0, _useNavigationHelpers.useNavigationHelpers)({
        id: options.id,
        onAction,
        getState,
        emitter,
        router,
        stateRef
    });
    (0, _useFocusedListenersChildrenAdapter.useFocusedListenersChildrenAdapter)({
        navigation,
        focusedListeners: childListeners.focus
    });
    (0, _useOnGetState.useOnGetState)({
        getState,
        getStateListeners: keyedListeners.getState
    });
    var _useDescriptors1 = (0, _useDescriptors.useDescriptors)({
        state,
        screens,
        navigation,
        screenOptions,
        screenLayout,
        onAction,
        getState,
        setState,
        onRouteFocus,
        addListener,
        addKeyedListener,
        router,
        // @ts-expect-error: this should have both core and custom events, but too much work right now
        emitter
    }), describe = _useDescriptors1.describe, descriptors = _useDescriptors1.descriptors;
    (0, _useCurrentRender.useCurrentRender)({
        state,
        navigation,
        descriptors
    });
    var NavigationContent = (0, _useComponent.useComponent)((children)=>{
        var element = layout != null ? layout({
            state,
            descriptors,
            navigation,
            children
        }) : children;
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_NavigationHelpersContext.NavigationHelpersContext.Provider, {
            value: navigation,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_useNavigationState.NavigationStateListenerProvider, {
                state: state,
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_PreventRemoveProvider.PreventRemoveProvider, {
                    children: element
                })
            })
        });
    });
    return {
        state,
        navigation,
        describe,
        descriptors,
        NavigationContent
    };
} //# sourceMappingURL=useNavigationBuilder.js.map


}),
22565: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useNavigationCache", ({
    enumerable: true,
    get: function() {
        return useNavigationCache;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _object_without_properties = __webpack_require__(86136);
var _to_consumable_array = __webpack_require__(92716);
var _routers = __webpack_require__(93675);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationBuilderContext = __webpack_require__(4323);
function useNavigationCache(ref) {
    var state = ref.state, getState = ref.getState, navigation = ref.navigation, setOptions = ref.setOptions, router = ref.router, emitter = ref.emitter;
    var stackRef = _react.useContext(_NavigationBuilderContext.NavigationBuilderContext).stackRef;
    var base = _react.useMemo(()=>{
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var emit = navigation.emit, rest = _object_without_properties._(navigation, [
            "emit"
        ]);
        var actions = _object_spread._({}, router.actionCreators, _routers.CommonActions);
        var dispatch = ()=>{
            throw new Error('Actions cannot be dispatched from a placeholder screen.');
        };
        var helpers = Object.keys(actions).reduce((acc, name)=>{
            acc[name] = dispatch;
            return acc;
        }, {});
        return _object_spread_props._(_object_spread._({}, rest, helpers), {
            addListener: ()=>{
                // Event listeners are not supported for placeholder screens
                return ()=>{
                // Empty function
                };
            },
            removeListener: ()=>{
            // Event listeners are not supported for placeholder screens
            },
            dispatch,
            getParent: (id)=>{
                if (id !== undefined && id === rest.getId()) {
                    return base;
                }
                return rest.getParent(id);
            },
            setOptions: ()=>{
                throw new Error('Options cannot be set from a placeholder screen.');
            },
            isFocused: ()=>false
        });
    }, [
        navigation,
        router.actionCreators
    ]);
    // Cache object which holds navigation objects for each screen
    // We use `React.useMemo` instead of `React.useRef` coz we want to invalidate it when deps change
    // In reality, these deps will rarely change, if ever
    var cache = _react.useMemo(()=>({
            current: {}
        }), // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        base,
        getState,
        navigation,
        setOptions,
        emitter
    ]);
    cache.current = state.routes.reduce((acc, route)=>{
        var previous = cache.current[route.key];
        if (previous) {
            // If a cached navigation object already exists, reuse it
            acc[route.key] = previous;
        } else {
            var dispatch = (thunk)=>{
                var action = typeof thunk === 'function' ? thunk(getState()) : thunk;
                if (action != null) {
                    navigation.dispatch(_object_spread._({
                        source: route.key
                    }, action));
                }
            };
            var withStack = (callback)=>{
                var isStackSet = false;
                try {
                    if (false) {}
                    callback();
                } finally{
                    if (isStackSet && stackRef) {
                        stackRef.current = undefined;
                    }
                }
            };
            var actions = _object_spread._({}, router.actionCreators, _routers.CommonActions);
            var helpers = Object.keys(actions).reduce((acc, name)=>{
                var _actions;
                acc[name] = (...args)=>withStack(()=>// @ts-expect-error: name is a valid key, but TypeScript is dumb
                        dispatch((_actions = actions)[name].apply(_actions, _to_consumable_array._(args))));
                return acc;
            }, {});
            acc[route.key] = _object_spread_props._(_object_spread._({}, base, helpers, emitter.create(route.key)), {
                dispatch: (thunk)=>withStack(()=>dispatch(thunk)),
                getParent: (id)=>{
                    if (id !== undefined && id === base.getId()) {
                        // If the passed id is the same as the current navigation id,
                        // we return the cached navigation object for the relevant route
                        return acc[route.key];
                    }
                    return base.getParent(id);
                },
                setOptions: (options)=>{
                    setOptions((o)=>_object_spread_props._(_object_spread._({}, o), {
                            [route.key]: _object_spread._({}, o[route.key], options)
                        }));
                },
                isFocused: ()=>{
                    var state = base.getState();
                    if (state.routes[state.index].key !== route.key) {
                        return false;
                    }
                    // If the current screen is focused, we also need to check if parent navigator is focused
                    // This makes sure that we return the focus state in the whole tree, not just this navigator
                    return navigation ? navigation.isFocused() : true;
                }
            });
        }
        return acc;
    }, {});
    return {
        base,
        navigations: cache.current
    };
} //# sourceMappingURL=useNavigationCache.js.map


}),
48283: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useNavigationContainerRef", ({
    enumerable: true,
    get: function() {
        return useNavigationContainerRef;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _createNavigationContainerRef = __webpack_require__(52249);
function useNavigationContainerRef() {
    var navigation = _react.useRef(null);
    if (navigation.current == null) {
        navigation.current = (0, _createNavigationContainerRef.createNavigationContainerRef)();
    }
    return navigation.current;
} //# sourceMappingURL=useNavigationContainerRef.js.map


}),
36491: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useNavigationHelpers", ({
    enumerable: true,
    get: function() {
        return useNavigationHelpers;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _to_consumable_array = __webpack_require__(92716);
var _routers = __webpack_require__(93675);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationContext = __webpack_require__(10776);
var _types = __webpack_require__(77808);
var _UnhandledActionContext = __webpack_require__(16497);
// This is to make TypeScript compiler happy
// eslint-disable-next-line @typescript-eslint/no-unused-expressions
_types.PrivateValueStore;
function useNavigationHelpers(ref) {
    var navigatorId = ref.id, onAction = ref.onAction, getState = ref.getState, emitter = ref.emitter, router = ref.router, stateRef = ref.stateRef;
    var onUnhandledAction = _react.useContext(_UnhandledActionContext.UnhandledActionContext);
    var parentNavigationHelpers = _react.useContext(_NavigationContext.NavigationContext);
    return _react.useMemo(()=>{
        var dispatch = (op)=>{
            var action = typeof op === 'function' ? op(getState()) : op;
            var handled = onAction(action);
            if (!handled) {
                onUnhandledAction === null || onUnhandledAction === void 0 ? void 0 : onUnhandledAction(action);
            }
        };
        var actions = _object_spread._({}, router.actionCreators, _routers.CommonActions);
        var helpers = Object.keys(actions).reduce((acc, name)=>{
            var _actions;
            // @ts-expect-error: name is a valid key, but TypeScript is dumb
            acc[name] = (...args)=>dispatch((_actions = actions)[name].apply(_actions, _to_consumable_array._(args)));
            return acc;
        }, {});
        var navigationHelpers = _object_spread_props._(_object_spread._({}, parentNavigationHelpers, helpers), {
            dispatch,
            emit: emitter.emit,
            isFocused: parentNavigationHelpers ? parentNavigationHelpers.isFocused : ()=>true,
            canGoBack: ()=>{
                var state = getState();
                return router.getStateForAction(state, _routers.CommonActions.goBack(), {
                    routeNames: state.routeNames,
                    routeParamList: {},
                    routeGetIdList: {}
                }) !== null || (parentNavigationHelpers === null || parentNavigationHelpers === void 0 ? void 0 : parentNavigationHelpers.canGoBack()) || false;
            },
            getId: ()=>navigatorId,
            getParent: (id)=>{
                if (id !== undefined) {
                    var current = navigationHelpers;
                    while(current && id !== current.getId()){
                        current = current.getParent();
                    }
                    return current;
                }
                return parentNavigationHelpers;
            },
            getState: ()=>{
                // FIXME: Workaround for when the state is read during render
                // By this time, we haven't committed the new state yet
                // Without this `useSyncExternalStore` will keep reading the old state
                // This may result in `useNavigationState` or `useIsFocused` returning wrong values
                // Apart from `useSyncExternalStore`, `getState` should never be called during render
                if (stateRef.current != null) {
                    return stateRef.current;
                }
                return getState();
            }
        });
        return navigationHelpers;
    }, [
        router,
        parentNavigationHelpers,
        emitter.emit,
        getState,
        onAction,
        onUnhandledAction,
        navigatorId,
        stateRef
    ]);
} //# sourceMappingURL=useNavigationHelpers.js.map


}),
11476: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useNavigationIndependentTree", ({
    enumerable: true,
    get: function() {
        return useNavigationIndependentTree;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationIndependentTreeContext = __webpack_require__(19771);
function useNavigationIndependentTree() {
    return _react.useContext(_NavigationIndependentTreeContext.NavigationIndependentTreeContext);
} //# sourceMappingURL=useNavigationIndependentTree.js.map


}),
84827: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get NavigationStateListenerProvider () {
        return NavigationStateListenerProvider;
    },
    get useNavigationState () {
        return useNavigationState;
    }
});
var _interop_require_default = __webpack_require__(66705);
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _uselatestcallback = /*#__PURE__*/ _interop_require_default._(__webpack_require__(694));
var _withselector = __webpack_require__(8352);
var _useClientLayoutEffect = __webpack_require__(18391);
var _jsxruntime = __webpack_require__(70095);
function useNavigationState(selector) {
    var stateListener = _react.useContext(NavigationStateListenerContext);
    if (stateListener == null) {
        throw new Error('useNavigationState must be used within a NavigationStateListenerProvider');
    }
    var value = (0, _withselector.useSyncExternalStoreWithSelector)(stateListener.subscribe, // @ts-expect-error: this is unsafe, but needed to make the generic work
    stateListener.getState, stateListener.getState, selector);
    return value;
}
function NavigationStateListenerProvider(ref) {
    var state = ref.state, children = ref.children;
    var listeners = _react.useRef([]);
    var getState = (0, _uselatestcallback.default)(()=>state);
    var subscribe = (0, _uselatestcallback.default)((callback)=>{
        listeners.current.push(callback);
        return ()=>{
            listeners.current = listeners.current.filter((cb)=>cb !== callback);
        };
    });
    (0, _useClientLayoutEffect.useClientLayoutEffect)(()=>{
        listeners.current.forEach((callback)=>callback());
    }, [
        state
    ]);
    var context = _react.useMemo(()=>({
            getState,
            subscribe
        }), [
        getState,
        subscribe
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(NavigationStateListenerContext.Provider, {
        value: context,
        children: children
    });
}
var NavigationStateListenerContext = /*#__PURE__*/ _react.createContext(undefined); //# sourceMappingURL=useNavigationState.js.map


}),
44406: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useOnAction", ({
    enumerable: true,
    get: function() {
        return useOnAction;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _DeprecatedNavigationInChildContext = __webpack_require__(71777);
var _NavigationBuilderContext = __webpack_require__(4323);
var _useOnPreventRemove = __webpack_require__(70618);
function useOnAction(ref) {
    var router = ref.router, getState = ref.getState, setState = ref.setState, key = ref.key, actionListeners = ref.actionListeners, beforeRemoveListeners = ref.beforeRemoveListeners, routerConfigOptions = ref.routerConfigOptions, emitter = ref.emitter;
    var _React_useContext = _react.useContext(_NavigationBuilderContext.NavigationBuilderContext), onActionParent = _React_useContext.onAction, onRouteFocusParent = _React_useContext.onRouteFocus, addListenerParent = _React_useContext.addListener, onDispatchAction = _React_useContext.onDispatchAction;
    var navigationInChildEnabled = _react.useContext(_DeprecatedNavigationInChildContext.DeprecatedNavigationInChildContext);
    var routerConfigOptionsRef = _react.useRef(routerConfigOptions);
    _react.useEffect(()=>{
        routerConfigOptionsRef.current = routerConfigOptions;
    });
    var onAction = _react.useCallback((action, ref)=>{
        var visitedNavigators = ref === void 0 ? new Set() : ref;
        var state = getState();
        // Since actions can bubble both up and down, they could come to the same navigator again
        // We keep track of navigators which have already tried to handle the action and return if it's already visited
        if (visitedNavigators.has(state.key)) {
            return false;
        }
        visitedNavigators.add(state.key);
        if (typeof action.target !== 'string' || action.target === state.key) {
            var result = router.getStateForAction(state, action, routerConfigOptionsRef.current);
            // If a target is specified and set to current navigator, the action shouldn't bubble
            // So instead of `null`, we use the state object for such cases to signal that action was handled
            result = result === null && action.target === state.key ? state : result;
            if (result !== null) {
                onDispatchAction(action, state === result);
                if (state !== result) {
                    var isPrevented = (0, _useOnPreventRemove.shouldPreventRemove)(emitter, beforeRemoveListeners, state.routes, result.routes, action);
                    if (isPrevented) {
                        return true;
                    }
                    setState(result);
                }
                if (onRouteFocusParent !== undefined) {
                    // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree
                    // This means we need to focus all of the parent navigators of this navigator as well
                    var shouldFocus = router.shouldActionChangeFocus(action);
                    if (shouldFocus && key !== undefined) {
                        onRouteFocusParent(key);
                    }
                }
                return true;
            }
        }
        if (onActionParent !== undefined) {
            // Bubble action to the parent if the current navigator didn't handle it
            if (onActionParent(action, visitedNavigators)) {
                return true;
            }
        }
        if (typeof action.target === 'string' || // For backward compatibility
        action.type === 'NAVIGATE_DEPRECATED' || navigationInChildEnabled) {
            // If the action wasn't handled by current navigator or a parent navigator, let children handle it
            // Handling this when target isn't specified is deprecated and will be removed in the future
            for(var i = actionListeners.length - 1; i >= 0; i--){
                var listener = actionListeners[i];
                if (listener(action, visitedNavigators)) {
                    return true;
                }
            }
        }
        return false;
    }, [
        actionListeners,
        beforeRemoveListeners,
        emitter,
        getState,
        navigationInChildEnabled,
        key,
        onActionParent,
        onDispatchAction,
        onRouteFocusParent,
        router,
        setState
    ]);
    (0, _useOnPreventRemove.useOnPreventRemove)({
        getState,
        emitter,
        beforeRemoveListeners
    });
    _react.useEffect(()=>addListenerParent === null || addListenerParent === void 0 ? void 0 : addListenerParent('action', onAction), [
        addListenerParent,
        onAction
    ]);
    return onAction;
} //# sourceMappingURL=useOnAction.js.map


}),
62201: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useOnGetState", ({
    enumerable: true,
    get: function() {
        return useOnGetState;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _isArrayEqual = __webpack_require__(3311);
var _NavigationBuilderContext = __webpack_require__(4323);
var _NavigationRouteContext = __webpack_require__(39928);
function useOnGetState(ref) {
    var getState = ref.getState, getStateListeners = ref.getStateListeners;
    var addKeyedListener = _react.useContext(_NavigationBuilderContext.NavigationBuilderContext).addKeyedListener;
    var route = _react.useContext(_NavigationRouteContext.NavigationRouteContext);
    var key = route ? route.key : 'root';
    var getRehydratedState = _react.useCallback(()=>{
        var state = getState();
        // Avoid returning new route objects if we don't need to
        var routes = state.routes.map((route)=>{
            var _getStateListeners_route_key;
            var childState = (_getStateListeners_route_key = getStateListeners[route.key]) === null || _getStateListeners_route_key === void 0 ? void 0 : _getStateListeners_route_key.call(getStateListeners);
            if (route.state === childState) {
                return route;
            }
            return _object_spread_props._(_object_spread._({}, route), {
                state: childState
            });
        });
        if ((0, _isArrayEqual.isArrayEqual)(state.routes, routes)) {
            return state;
        }
        return _object_spread_props._(_object_spread._({}, state), {
            routes
        });
    }, [
        getState,
        getStateListeners
    ]);
    _react.useEffect(()=>{
        return addKeyedListener === null || addKeyedListener === void 0 ? void 0 : addKeyedListener('getState', key, getRehydratedState);
    }, [
        addKeyedListener,
        getRehydratedState,
        key
    ]);
} //# sourceMappingURL=useOnGetState.js.map


}),
70618: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get shouldPreventRemove () {
        return shouldPreventRemove;
    },
    get useOnPreventRemove () {
        return useOnPreventRemove;
    }
});
var _interop_require_wildcard = __webpack_require__(83610);
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationBuilderContext = __webpack_require__(4323);
var _NavigationRouteContext = __webpack_require__(39928);
var VISITED_ROUTE_KEYS = Symbol('VISITED_ROUTE_KEYS');
var shouldPreventRemove = (emitter, beforeRemoveListeners, currentRoutes, nextRoutes, action)=>{
    var nextRouteKeys = nextRoutes.map((route)=>route.key);
    // Call these in reverse order so last screens handle the event first
    var removedRoutes = currentRoutes.filter((route)=>!nextRouteKeys.includes(route.key)).reverse();
    var visitedRouteKeys = // @ts-expect-error: add this property to mark that we've already emitted this action
    action[VISITED_ROUTE_KEYS] ?? new Set();
    var beforeRemoveAction = _object_spread_props._(_object_spread._({}, action), {
        [VISITED_ROUTE_KEYS]: visitedRouteKeys
    });
    for (var route of removedRoutes){
        var _beforeRemoveListeners_route_key;
        if (visitedRouteKeys.has(route.key)) {
            continue;
        }
        // First, we need to check if any child screens want to prevent it
        var isPrevented = (_beforeRemoveListeners_route_key = beforeRemoveListeners[route.key]) === null || _beforeRemoveListeners_route_key === void 0 ? void 0 : _beforeRemoveListeners_route_key.call(beforeRemoveListeners, beforeRemoveAction);
        if (isPrevented) {
            return true;
        }
        visitedRouteKeys.add(route.key);
        var event = emitter.emit({
            type: 'beforeRemove',
            target: route.key,
            data: {
                action: beforeRemoveAction
            },
            canPreventDefault: true
        });
        if (event.defaultPrevented) {
            return true;
        }
    }
    return false;
};
function useOnPreventRemove(ref) {
    var getState = ref.getState, emitter = ref.emitter, beforeRemoveListeners = ref.beforeRemoveListeners;
    var addKeyedListener = _react.useContext(_NavigationBuilderContext.NavigationBuilderContext).addKeyedListener;
    var route = _react.useContext(_NavigationRouteContext.NavigationRouteContext);
    var routeKey = route === null || route === void 0 ? void 0 : route.key;
    _react.useEffect(()=>{
        if (routeKey) {
            return addKeyedListener === null || addKeyedListener === void 0 ? void 0 : addKeyedListener('beforeRemove', routeKey, (action)=>{
                var state = getState();
                return shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, [], action);
            });
        }
    }, [
        addKeyedListener,
        beforeRemoveListeners,
        emitter,
        getState,
        routeKey
    ]);
} //# sourceMappingURL=useOnPreventRemove.js.map


}),
79969: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useOnRouteFocus", ({
    enumerable: true,
    get: function() {
        return useOnRouteFocus;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationBuilderContext = __webpack_require__(4323);
function useOnRouteFocus(ref) {
    var router = ref.router, getState = ref.getState, sourceRouteKey = ref.key, setState = ref.setState;
    var _React_useContext = _react.useContext(_NavigationBuilderContext.NavigationBuilderContext), onRouteFocusParent = _React_useContext.onRouteFocus;
    return _react.useCallback((key)=>{
        var state = getState();
        var result = router.getStateForRouteFocus(state, key);
        if (result !== state) {
            setState(result);
        }
        if (onRouteFocusParent !== undefined && sourceRouteKey !== undefined) {
            onRouteFocusParent(sourceRouteKey);
        }
    }, [
        getState,
        onRouteFocusParent,
        router,
        setState,
        sourceRouteKey
    ]);
} //# sourceMappingURL=useOnRouteFocus.js.map


}),
50920: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useOptionsGetters", ({
    enumerable: true,
    get: function() {
        return useOptionsGetters;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationBuilderContext = __webpack_require__(4323);
var _NavigationStateContext = __webpack_require__(16558);
function useOptionsGetters(ref) {
    var key = ref.key, options = ref.options, navigation = ref.navigation;
    var optionsRef = _react.useRef(options);
    var optionsGettersFromChildRef = _react.useRef({});
    var onOptionsChange = _react.useContext(_NavigationBuilderContext.NavigationBuilderContext).onOptionsChange;
    var _React_useContext = _react.useContext(_NavigationStateContext.NavigationStateContext), parentAddOptionsGetter = _React_useContext.addOptionsGetter;
    var optionsChangeListener = _react.useCallback(()=>{
        var isFocused = (navigation === null || navigation === void 0 ? void 0 : navigation.isFocused()) ?? true;
        var hasChildren = Object.keys(optionsGettersFromChildRef.current).length;
        if (isFocused && !hasChildren) {
            onOptionsChange(optionsRef.current ?? {});
        }
    }, [
        navigation,
        onOptionsChange
    ]);
    _react.useEffect(()=>{
        optionsRef.current = options;
        optionsChangeListener();
        return navigation === null || navigation === void 0 ? void 0 : navigation.addListener('focus', optionsChangeListener);
    }, [
        navigation,
        options,
        optionsChangeListener
    ]);
    var getOptionsFromListener = _react.useCallback(()=>{
        for(var key in optionsGettersFromChildRef.current){
            if (key in optionsGettersFromChildRef.current) {
                var _optionsGettersFromChildRef_current_key, _optionsGettersFromChildRef_current;
                var result = (_optionsGettersFromChildRef_current_key = (_optionsGettersFromChildRef_current = optionsGettersFromChildRef.current)[key]) === null || _optionsGettersFromChildRef_current_key === void 0 ? void 0 : _optionsGettersFromChildRef_current_key.call(_optionsGettersFromChildRef_current);
                // null means unfocused route
                if (result !== null) {
                    return result;
                }
            }
        }
        return null;
    }, []);
    var getCurrentOptions = _react.useCallback(()=>{
        var isFocused = (navigation === null || navigation === void 0 ? void 0 : navigation.isFocused()) ?? true;
        if (!isFocused) {
            return null;
        }
        var optionsFromListener = getOptionsFromListener();
        if (optionsFromListener !== null) {
            return optionsFromListener;
        }
        return optionsRef.current;
    }, [
        navigation,
        getOptionsFromListener
    ]);
    _react.useEffect(()=>{
        return parentAddOptionsGetter === null || parentAddOptionsGetter === void 0 ? void 0 : parentAddOptionsGetter(key, getCurrentOptions);
    }, [
        getCurrentOptions,
        parentAddOptionsGetter,
        key
    ]);
    var addOptionsGetter = _react.useCallback((key, getter)=>{
        optionsGettersFromChildRef.current[key] = getter;
        optionsChangeListener();
        return ()=>{
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete optionsGettersFromChildRef.current[key];
            optionsChangeListener();
        };
    }, [
        optionsChangeListener
    ]);
    return {
        addOptionsGetter,
        getCurrentOptions
    };
} //# sourceMappingURL=useOptionsGetters.js.map


}),
91191: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "usePreventRemove", ({
    enumerable: true,
    get: function() {
        return usePreventRemove;
    }
}));
var _interop_require_default = __webpack_require__(66705);
var _interop_require_wildcard = __webpack_require__(83610);
var _sliced_to_array = __webpack_require__(78474);
var _nonsecure = __webpack_require__(71289);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _uselatestcallback = /*#__PURE__*/ _interop_require_default._(__webpack_require__(694));
var _useNavigation = __webpack_require__(27316);
var _usePreventRemoveContext = __webpack_require__(88381);
var _useRoute = __webpack_require__(30692);
function usePreventRemove(preventRemove, callback) {
    var _React_useState = _sliced_to_array._(_react.useState(()=>(0, _nonsecure.nanoid)()), 1), id = _React_useState[0];
    var navigation = (0, _useNavigation.useNavigation)();
    var _useRoute1 = (0, _useRoute.useRoute)(), routeKey = _useRoute1.key;
    var setPreventRemove = (0, _usePreventRemoveContext.usePreventRemoveContext)().setPreventRemove;
    _react.useEffect(()=>{
        setPreventRemove(id, routeKey, preventRemove);
        return ()=>{
            setPreventRemove(id, routeKey, false);
        };
    }, [
        setPreventRemove,
        id,
        routeKey,
        preventRemove
    ]);
    var beforeRemoveListener = (0, _uselatestcallback.default)((e)=>{
        if (!preventRemove) {
            return;
        }
        e.preventDefault();
        callback({
            data: e.data
        });
    });
    _react.useEffect(()=>navigation === null || navigation === void 0 ? void 0 : navigation.addListener('beforeRemove', beforeRemoveListener), [
        navigation,
        beforeRemoveListener
    ]);
} //# sourceMappingURL=usePreventRemove.js.map


}),
88381: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "usePreventRemoveContext", ({
    enumerable: true,
    get: function() {
        return usePreventRemoveContext;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _PreventRemoveContext = __webpack_require__(43346);
function usePreventRemoveContext() {
    var value = _react.useContext(_PreventRemoveContext.PreventRemoveContext);
    if (value == null) {
        throw new Error("Couldn't find the prevent remove context. Is your component inside NavigationContent?");
    }
    return value;
} //# sourceMappingURL=usePreventRemoveContext.js.map


}),
30247: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useRegisterNavigator", ({
    enumerable: true,
    get: function() {
        return useRegisterNavigator;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _sliced_to_array = __webpack_require__(78474);
var _nonsecure = __webpack_require__(71289);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _EnsureSingleNavigator = __webpack_require__(25569);
function useRegisterNavigator() {
    var _React_useState = _sliced_to_array._(_react.useState(()=>(0, _nonsecure.nanoid)()), 1), key = _React_useState[0];
    var container = _react.useContext(_EnsureSingleNavigator.SingleNavigatorContext);
    if (container === undefined) {
        throw new Error("Couldn't register the navigator. Have you wrapped your app with 'NavigationContainer'?\n\nThis can also happen if there are multiple copies of '@react-navigation' packages installed.");
    }
    _react.useEffect(()=>{
        var register = container.register, unregister = container.unregister;
        register(key);
        return ()=>unregister(key);
    }, [
        container,
        key
    ]);
    return key;
} //# sourceMappingURL=useRegisterNavigator.js.map


}),
30692: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useRoute", ({
    enumerable: true,
    get: function() {
        return useRoute;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationRouteContext = __webpack_require__(39928);
function useRoute() {
    var route = _react.useContext(_NavigationRouteContext.NavigationRouteContext);
    if (route === undefined) {
        throw new Error("Couldn't find a route object. Is your component inside a screen in a navigator?");
    }
    return route;
} //# sourceMappingURL=useRoute.js.map


}),
62289: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get CHILD_STATE () {
        return CHILD_STATE;
    },
    get useRouteCache () {
        return useRouteCache;
    }
});
var _interop_require_wildcard = __webpack_require__(83610);
var _object_without_properties = __webpack_require__(86136);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _isRecordEqual = __webpack_require__(63950);
var CHILD_STATE = Symbol('CHILD_STATE');
function useRouteCache(routes) {
    // Cache object which holds route objects for each screen
    var cache = _react.useMemo(()=>({
            current: new Map()
        }), []);
    if (true) {
        // We don't want the overhead of creating extra maps every render in prod
        return routes;
    }
    cache.current = routes.reduce((acc, route)=>{
        var previous = cache.current.get(route.key);
        var state = route.state, routeWithoutState = _object_without_properties._(route, [
            "state"
        ]);
        var proxy;
        if (previous && (0, _isRecordEqual.isRecordEqual)(previous, routeWithoutState)) {
            // If a cached route object already exists, reuse it
            proxy = previous;
        } else {
            proxy = routeWithoutState;
        }
        if (false) { var value, key }
        Object.defineProperty(proxy, CHILD_STATE, {
            enumerable: false,
            configurable: true,
            value: state
        });
        acc.set(route.key, proxy);
        return acc;
    }, new Map());
    return Array.from(cache.current.values());
} //# sourceMappingURL=useRouteCache.js.map


}),
30819: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useScheduleUpdate", ({
    enumerable: true,
    get: function() {
        return useScheduleUpdate;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationBuilderContext = __webpack_require__(4323);
var _useClientLayoutEffect = __webpack_require__(18391);
function useScheduleUpdate(callback) {
    var _React_useContext = _react.useContext(_NavigationBuilderContext.NavigationBuilderContext), scheduleUpdate = _React_useContext.scheduleUpdate, flushUpdates = _React_useContext.flushUpdates;
    // FIXME: This is potentially unsafe
    // However, since we are using sync store, it might be fine
    scheduleUpdate(callback);
    (0, _useClientLayoutEffect.useClientLayoutEffect)(flushUpdates);
} //# sourceMappingURL=useScheduleUpdate.js.map


}),
96576: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useStateForPath", ({
    enumerable: true,
    get: function() {
        return useStateForPath;
    }
}));
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _NavigationFocusedRouteStateContext = __webpack_require__(79646);
function useStateForPath() {
    var state = _react.useContext(_NavigationFocusedRouteStateContext.NavigationFocusedRouteStateContext);
    return state;
} //# sourceMappingURL=useStateForPath.js.map


}),
89065: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useSyncState", ({
    enumerable: true,
    get: function() {
        return useSyncState;
    }
}));
var _interop_require_default = __webpack_require__(66705);
var _interop_require_wildcard = __webpack_require__(83610);
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(31399));
var _uselatestcallback = /*#__PURE__*/ _interop_require_default._(__webpack_require__(694));
var _deepFreeze = __webpack_require__(5552);
var createStore = (getInitialState)=>{
    var listeners = [];
    var initialized = false;
    var state;
    var getState = ()=>{
        if (initialized) {
            return state;
        }
        initialized = true;
        state = (0, _deepFreeze.deepFreeze)(getInitialState());
        return state;
    };
    var isBatching = false;
    var didUpdate = false;
    var setState = (newState)=>{
        state = (0, _deepFreeze.deepFreeze)(newState);
        didUpdate = true;
        if (!isBatching) {
            listeners.forEach((listener)=>listener());
        }
    };
    var subscribe = (callback)=>{
        listeners.push(callback);
        return ()=>{
            var index = listeners.indexOf(callback);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        };
    };
    var batchUpdates = (callback)=>{
        isBatching = true;
        callback();
        isBatching = false;
        if (didUpdate) {
            didUpdate = false;
            listeners.forEach((listener)=>listener());
        }
    };
    return {
        getState,
        setState,
        batchUpdates,
        subscribe
    };
};
function useSyncState(getInitialState) {
    var store = _react.useRef(createStore(getInitialState)).current;
    var state = _react.useSyncExternalStore(store.subscribe, store.getState, store.getState);
    _react.useDebugValue(state);
    var pendingUpdatesRef = _react.useRef([]);
    var scheduleUpdate = (0, _uselatestcallback.default)((callback)=>{
        pendingUpdatesRef.current.push(callback);
    });
    var flushUpdates = (0, _uselatestcallback.default)(()=>{
        var pendingUpdates = pendingUpdatesRef.current;
        pendingUpdatesRef.current = [];
        if (pendingUpdates.length !== 0) {
            store.batchUpdates(()=>{
                // Flush all the pending updates
                for (var update of pendingUpdates){
                    update();
                }
            });
        }
    });
    return {
        state,
        getState: store.getState,
        setState: store.setState,
        scheduleUpdate,
        flushUpdates
    };
} //# sourceMappingURL=useSyncState.js.map


}),
33434: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "validatePathConfig", ({
    enumerable: true,
    get: function() {
        return validatePathConfig;
    }
}));
var _object_spread = __webpack_require__(36192);
var _sliced_to_array = __webpack_require__(78474);
var formatToList = (items)=>Object.entries(items).map((ref)=>{
        var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
        return `- ${key} (${value})`;
    }).join('\n');
function validatePathConfig(config, ref) {
    var root = ref === void 0 ? true : ref;
    var validation = _object_spread._({
        path: 'string',
        initialRouteName: 'string',
        screens: 'object'
    }, root ? null : {
        alias: 'array',
        exact: 'boolean',
        stringify: 'object',
        parse: 'object'
    });
    if (typeof config !== 'object' || config === null) {
        throw new Error(`Expected the configuration to be an object, but got ${JSON.stringify(config)}.`);
    }
    var validationErrors = Object.fromEntries(Object.keys(config).map((key)=>{
        if (key in validation) {
            var type = validation[key];
            // @ts-expect-error: we know the key exists
            var value = config[key];
            if (value !== undefined) {
                if (type === 'array') {
                    if (!Array.isArray(value)) {
                        return [
                            key,
                            `expected 'Array', got '${typeof value}'`
                        ];
                    }
                } else if (typeof value !== type) {
                    return [
                        key,
                        `expected '${type}', got '${typeof value}'`
                    ];
                }
            }
        } else {
            return [
                key,
                'extraneous'
            ];
        }
        return null;
    }).filter(Boolean));
    if (Object.keys(validationErrors).length) {
        throw new Error(`Found invalid properties in the configuration:\n${formatToList(validationErrors)}\n\nYou can only specify the following properties:\n${formatToList(validation)}\n\nIf you want to specify configuration for screens, you need to specify them under a 'screens' property.\n\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`);
    }
    if (root && 'path' in config && typeof config.path === 'string' && config.path.includes(':')) {
        throw new Error(`Found invalid path '${config.path}'. The 'path' in the top-level configuration cannot contain patterns for params.`);
    }
    if ('screens' in config && config.screens) {
        Object.entries(config.screens).forEach((ref)=>{
            var _ref = _sliced_to_array._(ref, 2), _ = _ref[0], value = _ref[1];
            if (typeof value !== 'string') {
                validatePathConfig(value, false);
            }
        });
    }
} //# sourceMappingURL=validatePathConfig.js.map


}),
71289: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get customAlphabet () {
        return customAlphabet;
    },
    get nanoid () {
        return nanoid;
    }
});
var urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
var customAlphabet = (alphabet, ref)=>{
    var defaultSize = ref === void 0 ? 21 : ref;
    return (ref)=>{
        var size = ref === void 0 ? defaultSize : ref;
        var id = '';
        var i = size | 0;
        while(i--){
            id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
    };
};
var nanoid = (ref)=>{
    var size = ref === void 0 ? 21 : ref;
    var id = '';
    var i = size | 0;
    while(i--){
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};


}),
32713: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _object_without_properties = __webpack_require__(86136);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Link = Link;
var _core = __webpack_require__(78348);
var React = _interopRequireWildcard(__webpack_require__(31399));
var _reactNative = __webpack_require__(3345);
var _useLinkProps = __webpack_require__(99056);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Component to render link to another screen using a path.
 * Uses an anchor tag on the web.
 *
 * @param props.screen Name of the screen to navigate to (e.g. `'Feeds'`).
 * @param props.params Params to pass to the screen to navigate to (e.g. `{ sort: 'hot' }`).
 * @param props.href Optional absolute path to use for the href (e.g. `/feeds/hot`).
 * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.
 * @param props.children Child elements to render the content.
 */ function Link(_param) {
    var screen = _param.screen, params = _param.params, action = _param.action, href = _param.href, style = _param.style, rest = _object_without_properties._(_param, [
        "screen",
        "params",
        "action",
        "href",
        "style"
    ]);
    var _ref = (0, _core.useTheme)(), colors = _ref.colors, fonts = _ref.fonts;
    // @ts-expect-error: This is already type-checked by the prop types
    var props = (0, _useLinkProps.useLinkProps)({
        screen,
        params,
        action,
        href
    });
    var onPress = (e)=>{
        if ('onPress' in rest) {
            var _rest_onPress;
            (_rest_onPress = rest.onPress) === null || _rest_onPress === void 0 ? void 0 : _rest_onPress.call(rest, e);
        }
        // Let user prevent default behavior
        if (!e.defaultPrevented) {
            props.onPress(e);
        }
    };
    return /*#__PURE__*/ React.createElement(_reactNative.Text, _object_spread_props._(_object_spread._({}, props, rest, _reactNative.Platform.select({
        web: {
            onClick: onPress
        },
        default: {
            onPress
        }
    })), {
        style: [
            {
                color: colors.primary
            },
            fonts.regular,
            style
        ]
    }));
} //# sourceMappingURL=Link.js.map


}),
687: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LinkingContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(31399));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var MISSING_CONTEXT_ERROR = "Couldn't find a LinkingContext context.";
var LinkingContext = exports.LinkingContext = /*#__PURE__*/ React.createContext({
    get options () {
        throw new Error(MISSING_CONTEXT_ERROR);
    }
});
LinkingContext.displayName = 'LinkingContext'; //# sourceMappingURL=LinkingContext.js.map


}),
57500: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LocaleDirContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(31399));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var LocaleDirContext = exports.LocaleDirContext = /*#__PURE__*/ React.createContext('ltr');
LocaleDirContext.displayName = 'LocaleDirContext'; //# sourceMappingURL=LocaleDirContext.js.map


}),
92842: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _object_without_properties = __webpack_require__(86136);
var _sliced_to_array = __webpack_require__(78474);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NavigationContainer = void 0;
var _core = __webpack_require__(78348);
var React = _interopRequireWildcard(__webpack_require__(31399));
var _reactNative = __webpack_require__(3345);
var _useLatestCallback = _interopRequireDefault(__webpack_require__(694));
var _LinkingContext = __webpack_require__(687);
var _LocaleDirContext = __webpack_require__(57500);
var _DefaultTheme = __webpack_require__(16501);
var _UnhandledLinkingContext = __webpack_require__(51771);
var _useBackButton = __webpack_require__(79736);
var _useDocumentTitle = __webpack_require__(25957);
var _useLinking = __webpack_require__(28086);
var _useThenable = __webpack_require__(88446);
var _jsxRuntime = __webpack_require__(70095);
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
globalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();
/**
 * Container component which holds the navigation state designed for React Native apps.
 * This should be rendered at the root wrapping the whole app.
 *
 * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).
 * @param props.onReady Callback which is called after the navigation tree mounts.
 * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
 * @param props.onUnhandledAction Callback which is called when an action is not handled.
 * @param props.direction Text direction of the components. Defaults to `'ltr'`.
 * @param props.theme Theme object for the UI elements.
 * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.
 * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.
 * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.
 * @param props.children Child elements to render the content.
 * @param props.ref Ref object which refers to the navigation object containing helper methods.
 */ function NavigationContainerInner(_param, ref) {
    var _param_direction = _param.direction, direction = _param_direction === void 0 ? _reactNative.I18nManager.getConstants().isRTL ? 'rtl' : 'ltr' : _param_direction, _param_theme = _param.theme, theme = _param_theme === void 0 ? _DefaultTheme.DefaultTheme : _param_theme, linking = _param.linking, _param_fallback = _param.fallback, fallback = _param_fallback === void 0 ? null : _param_fallback, documentTitle = _param.documentTitle, onReady = _param.onReady, onStateChange = _param.onStateChange, rest = _object_without_properties._(_param, [
        "direction",
        "theme",
        "linking",
        "fallback",
        "documentTitle",
        "onReady",
        "onStateChange"
    ]);
    var isLinkingEnabled = linking ? linking.enabled !== false : false;
    if (linking === null || linking === void 0 ? void 0 : linking.config) {
        (0, _core.validatePathConfig)(linking.config);
    }
    var refContainer = React.useRef(null);
    (0, _useBackButton.useBackButton)(refContainer);
    (0, _useDocumentTitle.useDocumentTitle)(refContainer, documentTitle);
    var _React_useState = _sliced_to_array._(React.useState(), 2), lastUnhandledLink = _React_useState[0], setLastUnhandledLink = _React_useState[1];
    var getInitialState = (0, _useLinking.useLinking)(refContainer, _object_spread._({
        enabled: isLinkingEnabled,
        prefixes: []
    }, linking), setLastUnhandledLink).getInitialState;
    var linkingContext = React.useMemo(()=>({
            options: linking
        }), [
        linking
    ]);
    var unhandledLinkingContext = React.useMemo(()=>({
            lastUnhandledLink,
            setLastUnhandledLink
        }), [
        lastUnhandledLink,
        setLastUnhandledLink
    ]);
    var onReadyForLinkingHandling = (0, _useLatestCallback.default)(()=>{
        var _refContainer_current_getCurrentRoute, _refContainer_current;
        // If the screen path matches lastUnhandledLink, we do not track it
        var path = (_refContainer_current = refContainer.current) === null || _refContainer_current === void 0 ? void 0 : (_refContainer_current_getCurrentRoute = _refContainer_current.getCurrentRoute()) === null || _refContainer_current_getCurrentRoute === void 0 ? void 0 : _refContainer_current_getCurrentRoute.path;
        setLastUnhandledLink((previousLastUnhandledLink)=>{
            if (previousLastUnhandledLink === path) {
                return undefined;
            }
            return previousLastUnhandledLink;
        });
        onReady === null || onReady === void 0 ? void 0 : onReady();
    });
    var onStateChangeForLinkingHandling = (0, _useLatestCallback.default)((state)=>{
        var _refContainer_current_getCurrentRoute, _refContainer_current;
        // If the screen path matches lastUnhandledLink, we do not track it
        var path = (_refContainer_current = refContainer.current) === null || _refContainer_current === void 0 ? void 0 : (_refContainer_current_getCurrentRoute = _refContainer_current.getCurrentRoute()) === null || _refContainer_current_getCurrentRoute === void 0 ? void 0 : _refContainer_current_getCurrentRoute.path;
        setLastUnhandledLink((previousLastUnhandledLink)=>{
            if (previousLastUnhandledLink === path) {
                return undefined;
            }
            return previousLastUnhandledLink;
        });
        onStateChange === null || onStateChange === void 0 ? void 0 : onStateChange(state);
    });
    // Add additional linking related info to the ref
    // This will be used by the devtools
    React.useEffect(()=>{
        if (refContainer.current) {
            REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {
                get linking () {
                    return _object_spread_props._(_object_spread._({}, linking), {
                        enabled: isLinkingEnabled,
                        prefixes: (linking === null || linking === void 0 ? void 0 : linking.prefixes) ?? [],
                        getStateFromPath: (linking === null || linking === void 0 ? void 0 : linking.getStateFromPath) ?? _core.getStateFromPath,
                        getPathFromState: (linking === null || linking === void 0 ? void 0 : linking.getPathFromState) ?? _core.getPathFromState,
                        getActionFromState: (linking === null || linking === void 0 ? void 0 : linking.getActionFromState) ?? _core.getActionFromState
                    });
                }
            });
        }
    });
    var _ref = _sliced_to_array._((0, _useThenable.useThenable)(getInitialState), 2), isResolved = _ref[0], initialState = _ref[1];
    React.useImperativeHandle(ref, ()=>refContainer.current);
    var isLinkingReady = rest.initialState != null || !isLinkingEnabled || isResolved;
    if (!isLinkingReady) {
        // This is temporary until we have Suspense for data-fetching
        // Then the fallback will be handled by a parent `Suspense` component
        return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_core.ThemeProvider, {
            value: theme,
            children: fallback
        });
    }
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_LocaleDirContext.LocaleDirContext.Provider, {
        value: direction,
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_UnhandledLinkingContext.UnhandledLinkingContext.Provider, {
            value: unhandledLinkingContext,
            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_LinkingContext.LinkingContext.Provider, {
                value: linkingContext,
                children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_core.BaseNavigationContainer, _object_spread_props._(_object_spread._({}, rest), {
                    theme: theme,
                    onReady: onReadyForLinkingHandling,
                    onStateChange: onStateChangeForLinkingHandling,
                    initialState: rest.initialState == null ? initialState : rest.initialState,
                    ref: refContainer
                }))
            })
        })
    });
}
var NavigationContainer = exports.NavigationContainer = /*#__PURE__*/ React.forwardRef(NavigationContainerInner); //# sourceMappingURL=NavigationContainer.js.map


}),
19672: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ServerContainer = void 0;
var _core = __webpack_require__(78348);
var React = _interopRequireWildcard(__webpack_require__(31399));
var _ServerContext = __webpack_require__(72238);
var _jsxRuntime = __webpack_require__(70095);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Container component for server rendering.
 *
 * @param props.location Location object to base the initial URL for SSR.
 * @param props.children Child elements to render the content.
 * @param props.ref Ref object which contains helper methods.
 */ var ServerContainer = exports.ServerContainer = /*#__PURE__*/ React.forwardRef(function ServerContainer(ref, ref1) {
    var children = ref.children, location = ref.location;
    React.useEffect(()=>{
        console.error("'ServerContainer' should only be used on the server with 'react-dom/server' for SSR.");
    }, []);
    // eslint-disable-next-line @eslint-react/no-unstable-context-value
    var current = {};
    if (ref1) {
        var value = {
            getCurrentOptions () {
                return current.options;
            }
        };
        // We write to the `ref` during render instead of `React.useImperativeHandle`
        // This is because `useImperativeHandle` will update the ref after 'commit',
        // and there's no 'commit' phase during SSR.
        // Mutating ref during render is unsafe in concurrent mode, but we don't care about it for SSR.
        if (typeof ref1 === 'function') {
            ref1(value);
        } else {
            // @ts-expect-error: the TS types are incorrect and say that ref.current is readonly
            ref1.current = value;
        }
    }
    return(/*#__PURE__*/ // eslint-disable-next-line @eslint-react/no-unstable-context-value
    (0, _jsxRuntime.jsx)(_ServerContext.ServerContext.Provider, {
        value: {
            location
        },
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_core.CurrentRenderContext.Provider, {
            value: current,
            children: children
        })
    }));
}); //# sourceMappingURL=ServerContainer.js.map


}),
72238: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ServerContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(31399));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var ServerContext = exports.ServerContext = /*#__PURE__*/ React.createContext(undefined); //# sourceMappingURL=ServerContext.js.map


}),
51771: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UnhandledLinkingContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(31399));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var MISSING_CONTEXT_ERROR = "Couldn't find an UnhandledLinkingContext context.";
var UnhandledLinkingContext = exports.UnhandledLinkingContext = /*#__PURE__*/ React.createContext({
    get lastUnhandledLink () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setLastUnhandledLink () {
        throw new Error(MISSING_CONTEXT_ERROR);
    }
});
UnhandledLinkingContext.displayName = 'UnhandledLinkingContext'; //# sourceMappingURL=UnhandledLinkingContext.js.map


}),
89236: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _object_without_properties = __webpack_require__(86136);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createStaticNavigation = createStaticNavigation;
var _core = __webpack_require__(78348);
var React = _interopRequireWildcard(__webpack_require__(31399));
var _NavigationContainer = __webpack_require__(92842);
var _jsxRuntime = __webpack_require__(70095);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Create a navigation component from a static navigation config.
 * The returned component is a wrapper around `NavigationContainer`.
 *
 * @param tree Static navigation config.
 * @returns Navigation component to use in your app.
 */ function createStaticNavigation(tree) {
    var Component = (0, _core.createComponentForStaticNavigation)(tree, 'RootNavigator');
    function Navigation(_param, ref) {
        var linking = _param.linking, rest = _object_without_properties._(_param, [
            "linking"
        ]);
        var _linking_config, _linking_config1;
        var linkingConfig = React.useMemo(()=>{
            var _linking_config, _linking_config1, _linking_config2;
            var screens = (0, _core.createPathConfigForStaticNavigation)(tree, {
                initialRouteName: linking === null || linking === void 0 ? void 0 : (_linking_config = linking.config) === null || _linking_config === void 0 ? void 0 : _linking_config.initialRouteName
            }, (linking === null || linking === void 0 ? void 0 : linking.enabled) === 'auto');
            if (!screens) return;
            return {
                path: linking === null || linking === void 0 ? void 0 : (_linking_config1 = linking.config) === null || _linking_config1 === void 0 ? void 0 : _linking_config1.path,
                initialRouteName: linking === null || linking === void 0 ? void 0 : (_linking_config2 = linking.config) === null || _linking_config2 === void 0 ? void 0 : _linking_config2.initialRouteName,
                screens
            };
        }, [
            linking === null || linking === void 0 ? void 0 : linking.enabled,
            linking === null || linking === void 0 ? void 0 : (_linking_config = linking.config) === null || _linking_config === void 0 ? void 0 : _linking_config.path,
            linking === null || linking === void 0 ? void 0 : (_linking_config1 = linking.config) === null || _linking_config1 === void 0 ? void 0 : _linking_config1.initialRouteName
        ]);
        var memoizedLinking = React.useMemo(()=>{
            if (!linking) {
                return undefined;
            }
            var enabled = typeof linking.enabled === 'boolean' ? linking.enabled : (linkingConfig === null || linkingConfig === void 0 ? void 0 : linkingConfig.screens) != null;
            return _object_spread_props._(_object_spread._({}, linking), {
                enabled,
                config: linkingConfig
            });
        }, [
            linking,
            linkingConfig
        ]);
        if ((linking === null || linking === void 0 ? void 0 : linking.enabled) === true && (linkingConfig === null || linkingConfig === void 0 ? void 0 : linkingConfig.screens) == null) {
            throw new Error('Linking is enabled but no linking configuration was found for the screens.\n\n' + 'To solve this:\n' + "- Specify a 'linking' property for the screens you want to link to.\n" + "- Or set 'linking.enabled' to 'auto' to generate paths automatically.\n\n" + 'See usage guide: https://reactnavigation.org/docs/static-configuration#linking');
        }
        return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationContainer.NavigationContainer, _object_spread_props._(_object_spread._({}, rest), {
            ref: ref,
            linking: memoizedLinking,
            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(Component, {})
        }));
    }
    return /*#__PURE__*/ React.forwardRef(Navigation);
} //# sourceMappingURL=createStaticNavigation.js.map


}),
60234: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _to_array = __webpack_require__(12309);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.extractPathFromURL = extractPathFromURL;
var _escapeStringRegexp = _interopRequireDefault(__webpack_require__(48070));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function extractPathFromURL(prefixes, url) {
    for (var prefix of prefixes){
        var _prefix_match;
        var protocol = ((_prefix_match = prefix.match(/^[^:]+:/)) === null || _prefix_match === void 0 ? void 0 : _prefix_match[0]) ?? '';
        var host = prefix.replace(new RegExp(`^${(0, _escapeStringRegexp.default)(protocol)}`), '').replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
        .replace(/^\//, ''); // Remove extra leading slash
        var prefixRegex = new RegExp(`^${(0, _escapeStringRegexp.default)(protocol)}(/)*${host.split('.').map((it)=>it === '*' ? '[^/]+' : (0, _escapeStringRegexp.default)(it)).join('\\.')}`);
        var _url_split = _to_array._(url.split('?')), originAndPath = _url_split[0], searchParams = _url_split.slice(1);
        var normalizedURL = originAndPath.replace(/\/+/g, '/').concat(searchParams.length ? `?${searchParams.join('?')}` : '');
        if (prefixRegex.test(normalizedURL)) {
            return normalizedURL.replace(prefixRegex, '');
        }
    }
    return undefined;
} //# sourceMappingURL=extractPathFromURL.js.map


}),
54657: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _exportNames = {
    createStaticNavigation: true,
    Link: true,
    LinkingContext: true,
    LocaleDirContext: true,
    NavigationContainer: true,
    ServerContainer: true,
    DarkTheme: true,
    DefaultTheme: true,
    UNSTABLE_UnhandledLinkingContext: true,
    useLinkBuilder: true,
    useLinkProps: true,
    useLinkTo: true,
    useLocale: true,
    useScrollToTop: true
};
Object.defineProperty(exports, "DarkTheme", ({
    enumerable: true,
    get: function() {
        return _DarkTheme.DarkTheme;
    }
}));
Object.defineProperty(exports, "DefaultTheme", ({
    enumerable: true,
    get: function() {
        return _DefaultTheme.DefaultTheme;
    }
}));
Object.defineProperty(exports, "Link", ({
    enumerable: true,
    get: function() {
        return _Link.Link;
    }
}));
Object.defineProperty(exports, "LinkingContext", ({
    enumerable: true,
    get: function() {
        return _LinkingContext.LinkingContext;
    }
}));
Object.defineProperty(exports, "LocaleDirContext", ({
    enumerable: true,
    get: function() {
        return _LocaleDirContext.LocaleDirContext;
    }
}));
Object.defineProperty(exports, "NavigationContainer", ({
    enumerable: true,
    get: function() {
        return _NavigationContainer.NavigationContainer;
    }
}));
Object.defineProperty(exports, "ServerContainer", ({
    enumerable: true,
    get: function() {
        return _ServerContainer.ServerContainer;
    }
}));
Object.defineProperty(exports, "UNSTABLE_UnhandledLinkingContext", ({
    enumerable: true,
    get: function() {
        return _UnhandledLinkingContext.UnhandledLinkingContext;
    }
}));
Object.defineProperty(exports, "createStaticNavigation", ({
    enumerable: true,
    get: function() {
        return _createStaticNavigation.createStaticNavigation;
    }
}));
Object.defineProperty(exports, "useLinkBuilder", ({
    enumerable: true,
    get: function() {
        return _useLinkBuilder.useLinkBuilder;
    }
}));
Object.defineProperty(exports, "useLinkProps", ({
    enumerable: true,
    get: function() {
        return _useLinkProps.useLinkProps;
    }
}));
Object.defineProperty(exports, "useLinkTo", ({
    enumerable: true,
    get: function() {
        return _useLinkTo.useLinkTo;
    }
}));
Object.defineProperty(exports, "useLocale", ({
    enumerable: true,
    get: function() {
        return _useLocale.useLocale;
    }
}));
Object.defineProperty(exports, "useScrollToTop", ({
    enumerable: true,
    get: function() {
        return _useScrollToTop.useScrollToTop;
    }
}));
var _createStaticNavigation = __webpack_require__(89236);
var _Link = __webpack_require__(32713);
var _LinkingContext = __webpack_require__(687);
var _LocaleDirContext = __webpack_require__(57500);
var _NavigationContainer = __webpack_require__(92842);
var _ServerContainer = __webpack_require__(19672);
var _DarkTheme = __webpack_require__(16029);
var _DefaultTheme = __webpack_require__(16501);
var _types = __webpack_require__(42697);
Object.keys(_types).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _types[key];
        }
    });
});
var _UnhandledLinkingContext = __webpack_require__(51771);
var _useLinkBuilder = __webpack_require__(71578);
var _useLinkProps = __webpack_require__(99056);
var _useLinkTo = __webpack_require__(89426);
var _useLocale = __webpack_require__(47536);
var _useScrollToTop = __webpack_require__(3629);
var _core = __webpack_require__(78348);
Object.keys(_core).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _core[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _core[key];
        }
    });
}); //# sourceMappingURL=index.js.map


}),
16029: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DarkTheme = void 0;
var _fonts = __webpack_require__(50549);
var DarkTheme = exports.DarkTheme = {
    dark: true,
    colors: {
        primary: 'rgb(10, 132, 255)',
        background: 'rgb(1, 1, 1)',
        card: 'rgb(18, 18, 18)',
        text: 'rgb(229, 229, 231)',
        border: 'rgb(39, 39, 41)',
        notification: 'rgb(255, 69, 58)'
    },
    fonts: _fonts.fonts
}; //# sourceMappingURL=DarkTheme.js.map


}),
16501: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DefaultTheme = void 0;
var _fonts = __webpack_require__(50549);
var DefaultTheme = exports.DefaultTheme = {
    dark: false,
    colors: {
        primary: 'rgb(0, 122, 255)',
        background: 'rgb(242, 242, 242)',
        card: 'rgb(255, 255, 255)',
        text: 'rgb(28, 28, 30)',
        border: 'rgb(216, 216, 216)',
        notification: 'rgb(255, 59, 48)'
    },
    fonts: _fonts.fonts
}; //# sourceMappingURL=DefaultTheme.js.map


}),
50549: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fonts = void 0;
var _reactNative = __webpack_require__(3345);
var WEB_FONT_STACK = 'system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"';
var fonts = exports.fonts = _reactNative.Platform.select({
    web: {
        regular: {
            fontFamily: WEB_FONT_STACK,
            fontWeight: '400'
        },
        medium: {
            fontFamily: WEB_FONT_STACK,
            fontWeight: '500'
        },
        bold: {
            fontFamily: WEB_FONT_STACK,
            fontWeight: '600'
        },
        heavy: {
            fontFamily: WEB_FONT_STACK,
            fontWeight: '700'
        }
    },
    ios: {
        regular: {
            fontFamily: 'System',
            fontWeight: '400'
        },
        medium: {
            fontFamily: 'System',
            fontWeight: '500'
        },
        bold: {
            fontFamily: 'System',
            fontWeight: '600'
        },
        heavy: {
            fontFamily: 'System',
            fontWeight: '700'
        }
    },
    default: {
        regular: {
            fontFamily: 'sans-serif',
            fontWeight: 'normal'
        },
        medium: {
            fontFamily: 'sans-serif-medium',
            fontWeight: 'normal'
        },
        bold: {
            fontFamily: 'sans-serif',
            fontWeight: '600'
        },
        heavy: {
            fontFamily: 'sans-serif',
            fontWeight: '700'
        }
    }
}); //# sourceMappingURL=fonts.js.map


}),
42697: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=types.js.map


}),
79736: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useBackButton = useBackButton;
var React = _interopRequireWildcard(__webpack_require__(31399));
var _reactNative = __webpack_require__(3345);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useBackButton(ref) {
    React.useEffect(()=>{
        var subscription = _reactNative.BackHandler.addEventListener('hardwareBackPress', ()=>{
            var navigation = ref.current;
            if (navigation == null) {
                return false;
            }
            if (navigation.canGoBack()) {
                navigation.goBack();
                return true;
            }
            return false;
        });
        return ()=>subscription.remove();
    }, [
        ref
    ]);
} //# sourceMappingURL=useBackButton.native.js.map


}),
25957: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useDocumentTitle = useDocumentTitle;
// eslint-disable-next-line @eslint-react/hooks-extra/ensure-custom-hooks-using-other-hooks
function useDocumentTitle() {
// Noop for native platforms
} //# sourceMappingURL=useDocumentTitle.native.js.map


}),
71578: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLinkBuilder = useLinkBuilder;
var _core = __webpack_require__(78348);
var React = _interopRequireWildcard(__webpack_require__(31399));
var _LinkingContext = __webpack_require__(687);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var getRootStateForNavigate = (navigation, state)=>{
    var parent = navigation.getParent();
    if (parent) {
        var parentState = parent.getState();
        return getRootStateForNavigate(parent, {
            index: 0,
            routes: [
                _object_spread_props._(_object_spread._({}, parentState.routes[parentState.index]), {
                    state: state
                })
            ]
        });
    }
    return state;
};
/**
 * Helpers to build href or action based on the linking options.
 * @returns `buildHref` to build an `href` for screen and `buildAction` to build an action from an `href`.
 */ function useLinkBuilder() {
    var navigation = React.useContext(_core.NavigationHelpersContext);
    var linking = React.useContext(_LinkingContext.LinkingContext);
    var buildHref = React.useCallback((name, params)=>{
        var options = linking.options;
        if ((options === null || options === void 0 ? void 0 : options.enabled) === false) {
            return undefined;
        }
        var state = navigation ? getRootStateForNavigate(navigation, {
            index: 0,
            routes: [
                {
                    name,
                    params
                }
            ]
        }) : // If we couldn't find a navigation object in context, we're at root
        // So we'll construct a basic state object to use
        {
            index: 0,
            routes: [
                {
                    name,
                    params
                }
            ]
        };
        var path = (options === null || options === void 0 ? void 0 : options.getPathFromState) ? options.getPathFromState(state, options === null || options === void 0 ? void 0 : options.config) : (0, _core.getPathFromState)(state, options === null || options === void 0 ? void 0 : options.config);
        return path;
    }, [
        linking,
        navigation
    ]);
    var buildAction = React.useCallback((href)=>{
        if (!href.startsWith('/')) {
            throw new Error(`The href must start with '/' (${href}).`);
        }
        var options = linking.options;
        var state = (options === null || options === void 0 ? void 0 : options.getStateFromPath) ? options.getStateFromPath(href, options.config) : (0, _core.getStateFromPath)(href, options === null || options === void 0 ? void 0 : options.config);
        if (state) {
            var action = (0, _core.getActionFromState)(state, options === null || options === void 0 ? void 0 : options.config);
            return action ?? _core.CommonActions.reset(state);
        } else {
            throw new Error('Failed to parse the href to a navigation state.');
        }
    }, [
        linking
    ]);
    return {
        buildHref,
        buildAction
    };
} //# sourceMappingURL=useLinkBuilder.js.map


}),
99056: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLinkProps = useLinkProps;
var _core = __webpack_require__(78348);
var React = _interopRequireWildcard(__webpack_require__(31399));
var _reactNative = __webpack_require__(3345);
var _LinkingContext = __webpack_require__(687);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var getStateFromParams = (params)=>{
    if (params === null || params === void 0 ? void 0 : params.state) {
        return params.state;
    }
    if (params === null || params === void 0 ? void 0 : params.screen) {
        return {
            routes: [
                {
                    name: params.screen,
                    params: params.params,
                    // @ts-expect-error this is fine 
                    state: params.screen ? getStateFromParams(params.params) : undefined
                }
            ]
        };
    }
    return undefined;
};
/**
 * Hook to get props for an anchor tag so it can work with in page navigation.
 *
 * @param props.screen Name of the screen to navigate to (e.g. `'Feeds'`).
 * @param props.params Params to pass to the screen to navigate to (e.g. `{ sort: 'hot' }`).
 * @param props.href Optional absolute path to use for the href (e.g. `/feeds/hot`).
 * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.
 */ function useLinkProps(ref) {
    var screen = ref.screen, params = ref.params, href = ref.href, action = ref.action;
    var root = React.useContext(_core.NavigationContainerRefContext);
    var navigation = React.useContext(_core.NavigationHelpersContext);
    var options = React.useContext(_LinkingContext.LinkingContext).options;
    var onPress = (e)=>{
        var // @ts-expect-error: these properties exist on web, but not in React Native
        _e_currentTarget;
        // @ts-expect-error: these properties exist on web, but not in React Native
        var hasModifierKey = e.metaKey || e.altKey || e.ctrlKey || e.shiftKey; // ignore clicks with modifier keys
        // @ts-expect-error: these properties exist on web, but not in React Native
        var isLeftClick = e.button == null || e.button === 0; // only handle left clicks
        var isSelfTarget = [
            undefined,
            null,
            '',
            'self'
        ].includes((_e_currentTarget = e.currentTarget) === null || _e_currentTarget === void 0 ? void 0 : _e_currentTarget.target); // let browser handle "target=_blank" etc.
        var shouldHandle = false;
        if (_reactNative.Platform.OS !== 'web' || !e) {
            shouldHandle = true;
        } else if (!hasModifierKey && isLeftClick && isSelfTarget) {
            e.preventDefault();
            shouldHandle = true;
        }
        if (shouldHandle) {
            if (action) {
                if (navigation) {
                    navigation.dispatch(action);
                } else if (root) {
                    root.dispatch(action);
                } else {
                    throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
                }
            } else {
                // @ts-expect-error This is already type-checked by the prop types
                navigation === null || navigation === void 0 ? void 0 : navigation.navigate(screen, params);
            }
        }
    };
    var getPathFromStateHelper = (options === null || options === void 0 ? void 0 : options.getPathFromState) ?? _core.getPathFromState;
    return {
        href: href ?? (_reactNative.Platform.OS === 'web' && screen != null ? getPathFromStateHelper({
            routes: [
                {
                    // @ts-expect-error this is fine 
                    name: screen,
                    // @ts-expect-error this is fine 
                    params: params,
                    // @ts-expect-error this is fine 
                    state: getStateFromParams(params)
                }
            ]
        }, options === null || options === void 0 ? void 0 : options.config) : undefined),
        accessibilityRole: 'link',
        onPress
    };
} //# sourceMappingURL=useLinkProps.js.map


}),
89426: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLinkTo = useLinkTo;
var _core = __webpack_require__(78348);
var React = _interopRequireWildcard(__webpack_require__(31399));
var _useLinkBuilder = __webpack_require__(71578);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Helper to navigate to a screen using a href based on the linking options.
 * @returns function that receives the href to navigate to.
 */ function useLinkTo() {
    var navigation = React.useContext(_core.NavigationContainerRefContext);
    var buildAction = (0, _useLinkBuilder.useLinkBuilder)().buildAction;
    var linkTo = React.useCallback((href)=>{
        if (navigation === undefined) {
            throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
        }
        var action = buildAction(href);
        navigation.dispatch(action);
    }, [
        buildAction,
        navigation
    ]);
    return linkTo;
} //# sourceMappingURL=useLinkTo.js.map


}),
28086: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLinking = useLinking;
var _core = __webpack_require__(78348);
var React = _interopRequireWildcard(__webpack_require__(31399));
var _reactNative = __webpack_require__(3345);
var _extractPathFromURL = __webpack_require__(60234);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var linkingHandlers = [];
function useLinking(ref, ref1, onUnhandledLinking) {
    var _ref_enabled = ref1.enabled, enabled = _ref_enabled === void 0 ? true : _ref_enabled, prefixes = ref1.prefixes, filter = ref1.filter, config = ref1.config, _ref_getInitialURL = ref1.getInitialURL, getInitialURL = _ref_getInitialURL === void 0 ? ()=>Promise.race([
            _reactNative.Linking.getInitialURL(),
            new Promise((resolve)=>{
                // Timeout in 150ms if `getInitialState` doesn't resolve
                // Workaround for https://github.com/facebook/react-native/issues/25675
                setTimeout(resolve, 150);
            })
        ]) : _ref_getInitialURL, _ref_subscribe = ref1.subscribe, subscribe = _ref_subscribe === void 0 ? (listener)=>{
        var _reactNative_Linking_removeEventListener;
        var callback = (ref)=>{
            var url = ref.url;
            return listener(url);
        };
        var subscription = _reactNative.Linking.addEventListener('url', callback);
        // Storing this in a local variable stops Jest from complaining about import after teardown
        // @ts-expect-error: removeEventListener is not present in newer RN versions
        var removeEventListener = (_reactNative_Linking_removeEventListener = _reactNative.Linking.removeEventListener) === null || _reactNative_Linking_removeEventListener === void 0 ? void 0 : _reactNative_Linking_removeEventListener.bind(_reactNative.Linking);
        return ()=>{
            // https://github.com/facebook/react-native/commit/6d1aca806cee86ad76de771ed3a1cc62982ebcd7
            if (subscription === null || subscription === void 0 ? void 0 : subscription.remove) {
                subscription.remove();
            } else {
                removeEventListener === null || removeEventListener === void 0 ? void 0 : removeEventListener('url', callback);
            }
        };
    } : _ref_subscribe, _ref_getStateFromPath = ref1.getStateFromPath, getStateFromPath = _ref_getStateFromPath === void 0 ? _core.getStateFromPath : _ref_getStateFromPath, _ref_getActionFromState = ref1.getActionFromState, getActionFromState = _ref_getActionFromState === void 0 ? _core.getActionFromState : _ref_getActionFromState;
    var independent = (0, _core.useNavigationIndependentTree)();
    React.useEffect(()=>{
        if (true) {
            return undefined;
        }
        if (independent) {
            return undefined;
        }
        if (enabled !== false && linkingHandlers.length) {
            console.error([
                'Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:',
                "- You don't have multiple NavigationContainers in the app each with 'linking' enabled",
                '- Only a single instance of the root component is rendered',
                _reactNative.Platform.OS === 'android' ? "- You have set 'android:launchMode=singleTask' in the '<activity />' section of the 'AndroidManifest.xml' file to avoid launching multiple instances" : ''
            ].join('\n').trim());
        }
        var handler = Symbol();
        if (enabled !== false) {
            linkingHandlers.push(handler);
        }
        return ()=>{
            var index = linkingHandlers.indexOf(handler);
            if (index > -1) {
                linkingHandlers.splice(index, 1);
            }
        };
    }, [
        enabled,
        independent
    ]);
    // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners
    // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`
    // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect
    var enabledRef = React.useRef(enabled);
    var prefixesRef = React.useRef(prefixes);
    var filterRef = React.useRef(filter);
    var configRef = React.useRef(config);
    var getInitialURLRef = React.useRef(getInitialURL);
    var getStateFromPathRef = React.useRef(getStateFromPath);
    var getActionFromStateRef = React.useRef(getActionFromState);
    React.useEffect(()=>{
        enabledRef.current = enabled;
        prefixesRef.current = prefixes;
        filterRef.current = filter;
        configRef.current = config;
        getInitialURLRef.current = getInitialURL;
        getStateFromPathRef.current = getStateFromPath;
        getActionFromStateRef.current = getActionFromState;
    });
    var getStateFromURL = React.useCallback((url)=>{
        if (!url || filterRef.current && !filterRef.current(url)) {
            return undefined;
        }
        var path = (0, _extractPathFromURL.extractPathFromURL)(prefixesRef.current, url);
        return path !== undefined ? getStateFromPathRef.current(path, configRef.current) : undefined;
    }, []);
    var getInitialState = React.useCallback(()=>{
        var state;
        if (enabledRef.current) {
            var url = getInitialURLRef.current();
            if (url != null) {
                if (typeof url !== 'string') {
                    return url.then((url)=>{
                        var state = getStateFromURL(url);
                        if (typeof url === 'string') {
                            // If the link were handled, it gets cleared in NavigationContainer
                            onUnhandledLinking((0, _extractPathFromURL.extractPathFromURL)(prefixes, url));
                        }
                        return state;
                    });
                } else {
                    onUnhandledLinking((0, _extractPathFromURL.extractPathFromURL)(prefixes, url));
                }
            }
            state = getStateFromURL(url);
        }
        var thenable = {
            then (onfulfilled) {
                return Promise.resolve(onfulfilled ? onfulfilled(state) : state);
            },
            catch () {
                return thenable;
            }
        };
        return thenable;
    }, [
        getStateFromURL,
        onUnhandledLinking,
        prefixes
    ]);
    React.useEffect(()=>{
        var listener = (url)=>{
            if (!enabled) {
                return;
            }
            var navigation = ref.current;
            var state = navigation ? getStateFromURL(url) : undefined;
            if (navigation && state) {
                // If the link were handled, it gets cleared in NavigationContainer
                onUnhandledLinking((0, _extractPathFromURL.extractPathFromURL)(prefixes, url));
                var rootState = navigation.getRootState();
                if (state.routes.some((r)=>!(rootState === null || rootState === void 0 ? void 0 : rootState.routeNames.includes(r.name)))) {
                    return;
                }
                var action = getActionFromStateRef.current(state, configRef.current);
                if (action !== undefined) {
                    try {
                        navigation.dispatch(action);
                    } catch (e) {
                        // Ignore any errors from deep linking.
                        // This could happen in case of malformed links, navigation object not being initialized etc.
                        console.warn(`An error occurred when trying to handle the link '${url}': ${typeof e === 'object' && e != null && 'message' in e ? e.message : e}`);
                    }
                } else {
                    navigation.resetRoot(state);
                }
            }
        };
        return subscribe(listener);
    }, [
        enabled,
        getStateFromURL,
        onUnhandledLinking,
        prefixes,
        ref,
        subscribe
    ]);
    return {
        getInitialState
    };
} //# sourceMappingURL=useLinking.native.js.map


}),
47536: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLocale = useLocale;
var React = _interopRequireWildcard(__webpack_require__(31399));
var _LocaleDirContext = __webpack_require__(57500);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to access the text direction specified in the `NavigationContainer`.
 */ function useLocale() {
    var direction = React.useContext(_LocaleDirContext.LocaleDirContext);
    if (direction === undefined) {
        throw new Error("Couldn't determine the text direction. Is your component inside NavigationContainer?");
    }
    return {
        direction
    };
} //# sourceMappingURL=useLocale.js.map


}),
3629: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useScrollToTop = useScrollToTop;
var _core = __webpack_require__(78348);
var React = _interopRequireWildcard(__webpack_require__(31399));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function getScrollableNode(ref) {
    if (ref.current == null) {
        return null;
    }
    if ('scrollToTop' in ref.current || 'scrollTo' in ref.current || 'scrollToOffset' in ref.current || 'scrollResponderScrollTo' in ref.current) {
        // This is already a scrollable node.
        return ref.current;
    } else if ('getScrollResponder' in ref.current) {
        // If the view is a wrapper like FlatList, SectionList etc.
        // We need to use `getScrollResponder` to get access to the scroll responder
        return ref.current.getScrollResponder();
    } else if ('getNode' in ref.current) {
        // When a `ScrollView` is wrapped in `Animated.createAnimatedComponent`
        // we need to use `getNode` to get the ref to the actual scrollview.
        // Note that `getNode` is deprecated in newer versions of react-native
        // this is why we check if we already have a scrollable node above.
        return ref.current.getNode();
    } else {
        return ref.current;
    }
}
function useScrollToTop(ref) {
    var navigation = React.useContext(_core.NavigationContext);
    var route = (0, _core.useRoute)();
    if (navigation === undefined) {
        throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    React.useEffect(()=>{
        var tabNavigations = [];
        var currentNavigation = navigation;
        // If the screen is nested inside multiple tab navigators, we should scroll to top for any of them
        // So we need to find all the parent tab navigators and add the listeners there
        while(currentNavigation){
            if (currentNavigation.getState().type === 'tab') {
                tabNavigations.push(currentNavigation);
            }
            currentNavigation = currentNavigation.getParent();
        }
        if (tabNavigations.length === 0) {
            return;
        }
        var unsubscribers = tabNavigations.map((tab)=>{
            return tab.addListener(// We don't wanna import tab types here to avoid extra deps
            // in addition, there are multiple tab implementations
            // @ts-expect-error the `tabPress` event is only available when navigation type is tab
            'tabPress', (e)=>{
                // We should scroll to top only when the screen is focused
                var isFocused = navigation.isFocused();
                // In a nested stack navigator, tab press resets the stack to first screen
                // So we should scroll to top only when we are on first screen
                var isFirst = tabNavigations.includes(navigation) || navigation.getState().routes[0].key === route.key;
                // Run the operation in the next frame so we're sure all listeners have been run
                // This is necessary to know if preventDefault() has been called
                requestAnimationFrame(()=>{
                    var scrollable = getScrollableNode(ref);
                    if (isFocused && isFirst && scrollable && !e.defaultPrevented) {
                        if ('scrollToTop' in scrollable) {
                            scrollable.scrollToTop();
                        } else if ('scrollTo' in scrollable) {
                            scrollable.scrollTo({
                                y: 0,
                                animated: true
                            });
                        } else if ('scrollToOffset' in scrollable) {
                            scrollable.scrollToOffset({
                                offset: 0,
                                animated: true
                            });
                        } else if ('scrollResponderScrollTo' in scrollable) {
                            scrollable.scrollResponderScrollTo({
                                y: 0,
                                animated: true
                            });
                        }
                    }
                });
            });
        });
        return ()=>{
            unsubscribers.forEach((unsubscribe)=>unsubscribe());
        };
    }, [
        navigation,
        ref,
        route.key
    ]);
} //# sourceMappingURL=useScrollToTop.js.map


}),
88446: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _async_to_generator = __webpack_require__(11809);
var _sliced_to_array = __webpack_require__(78474);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useThenable = useThenable;
var React = _interopRequireWildcard(__webpack_require__(31399));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useThenable(create) {
    var _React_useState = _sliced_to_array._(React.useState(create), 1), promise = _React_useState[0];
    var initialState = [
        false,
        undefined
    ];
    // Check if our thenable is synchronous
    // eslint-disable-next-line promise/catch-or-return, promise/always-return
    promise.then((result)=>{
        initialState = [
            true,
            result
        ];
    });
    var _React_useState1 = _sliced_to_array._(React.useState(initialState), 2), state = _React_useState1[0], setState = _React_useState1[1];
    var _state = _sliced_to_array._(state, 1), resolved = _state[0];
    React.useEffect(()=>{
        var cancelled = false;
        var resolve = ()=>_async_to_generator._(function*() {
                var result;
                try {
                    result = yield promise;
                } finally{
                    if (!cancelled) {
                        setState([
                            true,
                            result
                        ]);
                    }
                }
            })();
        if (!resolved) {
            resolve();
        }
        return ()=>{
            cancelled = true;
        };
    }, [
        promise,
        resolved
    ]);
    return state;
} //# sourceMappingURL=useThenable.js.map


}),
41252: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "BaseRouter", ({
    enumerable: true,
    get: function() {
        return BaseRouter;
    }
}));
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _nonsecure = __webpack_require__(57024);
var BaseRouter = {
    getStateForAction (state, action) {
        switch(action.type){
            case 'SET_PARAMS':
            case 'REPLACE_PARAMS':
                {
                    var index = action.source ? state.routes.findIndex((r)=>r.key === action.source) : state.index;
                    if (index === -1) {
                        return null;
                    }
                    return _object_spread_props._(_object_spread._({}, state), {
                        routes: state.routes.map((r, i)=>i === index ? _object_spread_props._(_object_spread._({}, r), {
                                params: action.type === 'REPLACE_PARAMS' ? action.payload.params : _object_spread._({}, r.params, action.payload.params)
                            }) : r)
                    });
                }
            case 'RESET':
                {
                    var nextState = action.payload;
                    if (nextState.routes.length === 0 || nextState.routes.some((route)=>!state.routeNames.includes(route.name))) {
                        return null;
                    }
                    if (nextState.stale === false) {
                        if (state.routeNames.length !== nextState.routeNames.length || nextState.routeNames.some((name)=>!state.routeNames.includes(name))) {
                            return null;
                        }
                        return _object_spread_props._(_object_spread._({}, nextState), {
                            routes: nextState.routes.map((route)=>route.key ? route : _object_spread_props._(_object_spread._({}, route), {
                                    key: `${route.name}-${(0, _nonsecure.nanoid)()}`
                                }))
                        });
                    }
                    return nextState;
                }
            default:
                return null;
        }
    },
    shouldActionChangeFocus (action) {
        return action.type === 'NAVIGATE' || action.type === 'NAVIGATE_DEPRECATED';
    }
}; //# sourceMappingURL=BaseRouter.js.map


}),
42208: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get goBack () {
        return goBack;
    },
    get navigate () {
        return navigate;
    },
    get navigateDeprecated () {
        return navigateDeprecated;
    },
    get preload () {
        return preload;
    },
    get replaceParams () {
        return replaceParams;
    },
    get reset () {
        return reset;
    },
    get setParams () {
        return setParams;
    }
});
var _sliced_to_array = __webpack_require__(78474);
function goBack() {
    return {
        type: 'GO_BACK'
    };
}
function navigate(...args) {
    if (typeof args[0] === 'string') {
        var _args = _sliced_to_array._(args, 3), name = _args[0], params = _args[1], options = _args[2];
        if (typeof options === 'boolean') {
            console.warn(`Passing a boolean as the third argument to 'navigate' is deprecated. Pass '{ merge: true }' instead.`);
        }
        return {
            type: 'NAVIGATE',
            payload: {
                name,
                params,
                merge: typeof options === 'boolean' ? options : options === null || options === void 0 ? void 0 : options.merge,
                pop: options === null || options === void 0 ? void 0 : options.pop
            }
        };
    } else {
        var payload = args[0] || {};
        if (!('name' in payload)) {
            throw new Error('You need to specify a name when calling navigate with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigate for usage.');
        }
        return {
            type: 'NAVIGATE',
            payload
        };
    }
}
function navigateDeprecated(...args) {
    if (typeof args[0] === 'string') {
        return {
            type: 'NAVIGATE_DEPRECATED',
            payload: {
                name: args[0],
                params: args[1]
            }
        };
    } else {
        var payload = args[0] || {};
        if (!('name' in payload)) {
            throw new Error('You need to specify a name when calling navigateDeprecated with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigatelegacy for usage.');
        }
        return {
            type: 'NAVIGATE_DEPRECATED',
            payload
        };
    }
}
function reset(state) {
    return {
        type: 'RESET',
        payload: state
    };
}
function setParams(params) {
    return {
        type: 'SET_PARAMS',
        payload: {
            params
        }
    };
}
function replaceParams(params) {
    return {
        type: 'REPLACE_PARAMS',
        payload: {
            params
        }
    };
}
function preload(name, params) {
    return {
        type: 'PRELOAD',
        payload: {
            name,
            params
        }
    };
} //# sourceMappingURL=CommonActions.js.map


}),
11769: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get DrawerActions () {
        return DrawerActions;
    },
    get DrawerRouter () {
        return DrawerRouter;
    }
});
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _object_without_properties = __webpack_require__(86136);
var _to_consumable_array = __webpack_require__(92716);
var _nonsecure = __webpack_require__(57024);
var _TabRouter = __webpack_require__(77730);
var DrawerActions = _object_spread_props._(_object_spread._({}, _TabRouter.TabActions), {
    openDrawer () {
        return {
            type: 'OPEN_DRAWER'
        };
    },
    closeDrawer () {
        return {
            type: 'CLOSE_DRAWER'
        };
    },
    toggleDrawer () {
        return {
            type: 'TOGGLE_DRAWER'
        };
    }
});
function DrawerRouter(_param) {
    var _param_defaultStatus = _param.defaultStatus, defaultStatus = _param_defaultStatus === void 0 ? 'closed' : _param_defaultStatus, rest = _object_without_properties._(_param, [
        "defaultStatus"
    ]);
    var router = (0, _TabRouter.TabRouter)(rest);
    var isDrawerInHistory = (state)=>{
        var _state_history;
        return Boolean((_state_history = state.history) === null || _state_history === void 0 ? void 0 : _state_history.some((it)=>it.type === 'drawer'));
    };
    var addDrawerToHistory = (state)=>{
        if (isDrawerInHistory(state)) {
            return state;
        }
        return _object_spread_props._(_object_spread._({}, state), {
            history: _to_consumable_array._(state.history).concat([
                {
                    type: 'drawer',
                    status: defaultStatus === 'open' ? 'closed' : 'open'
                }
            ])
        });
    };
    var removeDrawerFromHistory = (state)=>{
        if (!isDrawerInHistory(state)) {
            return state;
        }
        return _object_spread_props._(_object_spread._({}, state), {
            history: state.history.filter((it)=>it.type !== 'drawer')
        });
    };
    var openDrawer = (state)=>{
        if (defaultStatus === 'open') {
            return removeDrawerFromHistory(state);
        }
        return addDrawerToHistory(state);
    };
    var closeDrawer = (state)=>{
        if (defaultStatus === 'open') {
            return addDrawerToHistory(state);
        }
        return removeDrawerFromHistory(state);
    };
    return _object_spread_props._(_object_spread._({}, router), {
        type: 'drawer',
        getInitialState (ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeGetIdList = ref.routeGetIdList;
            var state = router.getInitialState({
                routeNames,
                routeParamList,
                routeGetIdList
            });
            return _object_spread_props._(_object_spread._({}, state), {
                default: defaultStatus,
                stale: false,
                type: 'drawer',
                key: `drawer-${(0, _nonsecure.nanoid)()}`
            });
        },
        getRehydratedState (partialState, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeGetIdList = ref.routeGetIdList;
            if (partialState.stale === false) {
                return partialState;
            }
            var state = router.getRehydratedState(partialState, {
                routeNames,
                routeParamList,
                routeGetIdList
            });
            if (isDrawerInHistory(partialState)) {
                // Re-sync the drawer entry in history to correct it if it was wrong
                state = removeDrawerFromHistory(state);
                state = addDrawerToHistory(state);
            }
            return _object_spread_props._(_object_spread._({}, state), {
                default: defaultStatus,
                type: 'drawer',
                key: `drawer-${(0, _nonsecure.nanoid)()}`
            });
        },
        getStateForRouteFocus (state, key) {
            var result = router.getStateForRouteFocus(state, key);
            return closeDrawer(result);
        },
        getStateForAction (state, action, options) {
            switch(action.type){
                case 'OPEN_DRAWER':
                    return openDrawer(state);
                case 'CLOSE_DRAWER':
                    return closeDrawer(state);
                case 'TOGGLE_DRAWER':
                    if (isDrawerInHistory(state)) {
                        return removeDrawerFromHistory(state);
                    }
                    return addDrawerToHistory(state);
                case 'JUMP_TO':
                case 'NAVIGATE':
                case 'NAVIGATE_DEPRECATED':
                    {
                        var result = router.getStateForAction(state, action, options);
                        if (result != null && result.index !== state.index) {
                            return closeDrawer(result);
                        }
                        return result;
                    }
                case 'GO_BACK':
                    if (isDrawerInHistory(state)) {
                        return removeDrawerFromHistory(state);
                    }
                    return router.getStateForAction(state, action, options);
                default:
                    return router.getStateForAction(state, action, options);
            }
        },
        actionCreators: DrawerActions
    });
} //# sourceMappingURL=DrawerRouter.js.map


}),
26663: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get StackActions () {
        return StackActions;
    },
    get StackRouter () {
        return StackRouter;
    }
});
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _to_consumable_array = __webpack_require__(92716);
var _nonsecure = __webpack_require__(57024);
var _BaseRouter = __webpack_require__(41252);
var StackActions = {
    replace (name, params) {
        return {
            type: 'REPLACE',
            payload: {
                name,
                params
            }
        };
    },
    push (name, params) {
        return {
            type: 'PUSH',
            payload: {
                name,
                params
            }
        };
    },
    pop (ref) {
        var count = ref === void 0 ? 1 : ref;
        return {
            type: 'POP',
            payload: {
                count
            }
        };
    },
    popToTop () {
        return {
            type: 'POP_TO_TOP'
        };
    },
    popTo (name, params, options) {
        if (typeof options === 'boolean') {
            console.warn(`Passing a boolean as the third argument to 'popTo' is deprecated. Pass '{ merge: true }' instead.`);
        }
        return {
            type: 'POP_TO',
            payload: {
                name,
                params,
                merge: typeof options === 'boolean' ? options : options === null || options === void 0 ? void 0 : options.merge
            }
        };
    }
};
function StackRouter(options) {
    var router = _object_spread_props._(_object_spread._({}, _BaseRouter.BaseRouter), {
        type: 'stack',
        getInitialState (ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
            return {
                stale: false,
                type: 'stack',
                key: `stack-${(0, _nonsecure.nanoid)()}`,
                index: 0,
                routeNames,
                preloadedRoutes: [],
                routes: [
                    {
                        key: `${initialRouteName}-${(0, _nonsecure.nanoid)()}`,
                        name: initialRouteName,
                        params: routeParamList[initialRouteName]
                    }
                ]
            };
        },
        getRehydratedState (partialState, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var _state_preloadedRoutes;
            var state = partialState;
            if (state.stale === false) {
                return state;
            }
            var routes = state.routes.filter((route)=>routeNames.includes(route.name)).map((route)=>_object_spread_props._(_object_spread._({}, route), {
                    key: route.key || `${route.name}-${(0, _nonsecure.nanoid)()}`,
                    params: routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], route.params) : route.params
                }));
            var preloadedRoutes = ((_state_preloadedRoutes = state.preloadedRoutes) === null || _state_preloadedRoutes === void 0 ? void 0 : _state_preloadedRoutes.filter((route)=>routeNames.includes(route.name)).map((route)=>_object_spread_props._(_object_spread._({}, route), {
                    key: route.key || `${route.name}-${(0, _nonsecure.nanoid)()}`,
                    params: routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], route.params) : route.params
                }))) ?? [];
            if (routes.length === 0) {
                var initialRouteName = options.initialRouteName !== undefined ? options.initialRouteName : routeNames[0];
                routes.push({
                    key: `${initialRouteName}-${(0, _nonsecure.nanoid)()}`,
                    name: initialRouteName,
                    params: routeParamList[initialRouteName]
                });
            }
            return {
                stale: false,
                type: 'stack',
                key: `stack-${(0, _nonsecure.nanoid)()}`,
                index: routes.length - 1,
                routeNames,
                routes,
                preloadedRoutes
            };
        },
        getStateForRouteNamesChange (state, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeKeyChanges = ref.routeKeyChanges;
            var routes = state.routes.filter((route)=>routeNames.includes(route.name) && !routeKeyChanges.includes(route.name));
            if (routes.length === 0) {
                var initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
                routes.push({
                    key: `${initialRouteName}-${(0, _nonsecure.nanoid)()}`,
                    name: initialRouteName,
                    params: routeParamList[initialRouteName]
                });
            }
            return _object_spread_props._(_object_spread._({}, state), {
                routeNames,
                routes,
                index: Math.min(state.index, routes.length - 1)
            });
        },
        getStateForRouteFocus (state, key) {
            var index = state.routes.findIndex((r)=>r.key === key);
            if (index === -1 || index === state.index) {
                return state;
            }
            return _object_spread_props._(_object_spread._({}, state), {
                index,
                routes: state.routes.slice(0, index + 1)
            });
        },
        getStateForAction (state, action, options) {
            var routeParamList = options.routeParamList;
            switch(action.type){
                case 'REPLACE':
                    {
                        var index = action.target === state.key && action.source ? state.routes.findIndex((r)=>r.key === action.source) : state.index;
                        if (index === -1) {
                            return null;
                        }
                        var _action_payload = action.payload, name = _action_payload.name, params = _action_payload.params;
                        if (!state.routeNames.includes(name)) {
                            return null;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            routes: state.routes.map((route, i)=>i === index ? {
                                    key: `${name}-${(0, _nonsecure.nanoid)()}`,
                                    name,
                                    params: routeParamList[name] !== undefined ? _object_spread._({}, routeParamList[name], params) : params
                                } : route)
                        });
                    }
                case 'PUSH':
                case 'NAVIGATE':
                    {
                        if (!state.routeNames.includes(action.payload.name)) {
                            return null;
                        }
                        var getId = options.routeGetIdList[action.payload.name];
                        var id = getId === null || getId === void 0 ? void 0 : getId({
                            params: action.payload.params
                        });
                        var route;
                        if (id !== undefined) {
                            route = state.routes.findLast((route)=>route.name === action.payload.name && id === (getId === null || getId === void 0 ? void 0 : getId({
                                    params: route.params
                                })));
                        } else if (action.type === 'NAVIGATE') {
                            var currentRoute = state.routes[state.index];
                            // If the route matches the current one, then navigate to it
                            if (action.payload.name === currentRoute.name) {
                                route = currentRoute;
                            } else if (action.payload.pop) {
                                route = state.routes.findLast((route)=>route.name === action.payload.name);
                            }
                        }
                        if (!route) {
                            route = state.preloadedRoutes.find((route)=>route.name === action.payload.name && id === (getId === null || getId === void 0 ? void 0 : getId({
                                    params: route.params
                                })));
                        }
                        var params1;
                        if (action.type === 'NAVIGATE' && action.payload.merge && route) {
                            params1 = action.payload.params !== undefined || routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], route.params, action.payload.params) : route.params;
                        } else {
                            params1 = routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params;
                        }
                        var routes;
                        if (route) {
                            if (action.type === 'NAVIGATE' && action.payload.pop) {
                                routes = [];
                                // Get all routes until the matching one
                                for (var r of state.routes){
                                    if (r.key === route.key) {
                                        routes.push(_object_spread_props._(_object_spread._({}, route), {
                                            path: action.payload.path !== undefined ? action.payload.path : route.path,
                                            params: params1
                                        }));
                                        break;
                                    }
                                    routes.push(r);
                                }
                            } else {
                                routes = state.routes.filter((r)=>r.key !== route.key);
                                routes.push(_object_spread_props._(_object_spread._({}, route), {
                                    path: action.type === 'NAVIGATE' && action.payload.path !== undefined ? action.payload.path : route.path,
                                    params: params1
                                }));
                            }
                        } else {
                            routes = _to_consumable_array._(state.routes).concat([
                                {
                                    key: `${action.payload.name}-${(0, _nonsecure.nanoid)()}`,
                                    name: action.payload.name,
                                    path: action.type === 'NAVIGATE' ? action.payload.path : undefined,
                                    params: params1
                                }
                            ]);
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            index: routes.length - 1,
                            preloadedRoutes: state.preloadedRoutes.filter((route)=>routes[routes.length - 1].key !== route.key),
                            routes
                        });
                    }
                case 'NAVIGATE_DEPRECATED':
                    {
                        if (state.preloadedRoutes.find((route)=>route.name === action.payload.name && id1 === (getId1 === null || getId1 === void 0 ? void 0 : getId1({
                                params: route.params
                            })))) {
                            return null;
                        }
                        if (!state.routeNames.includes(action.payload.name)) {
                            return null;
                        }
                        // If the route already exists, navigate to that
                        var index1 = -1;
                        var getId1 = options.routeGetIdList[action.payload.name];
                        var id1 = getId1 === null || getId1 === void 0 ? void 0 : getId1({
                            params: action.payload.params
                        });
                        if (id1) {
                            index1 = state.routes.findIndex((route)=>route.name === action.payload.name && id1 === (getId1 === null || getId1 === void 0 ? void 0 : getId1({
                                    params: route.params
                                })));
                        } else if (state.routes[state.index].name === action.payload.name) {
                            index1 = state.index;
                        } else {
                            for(var i = state.routes.length - 1; i >= 0; i--){
                                if (state.routes[i].name === action.payload.name) {
                                    index1 = i;
                                    break;
                                }
                            }
                        }
                        if (index1 === -1) {
                            var routes1 = _to_consumable_array._(state.routes).concat([
                                {
                                    key: `${action.payload.name}-${(0, _nonsecure.nanoid)()}`,
                                    name: action.payload.name,
                                    params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                                }
                            ]);
                            return _object_spread_props._(_object_spread._({}, state), {
                                routes: routes1,
                                index: routes1.length - 1
                            });
                        }
                        var route1 = state.routes[index1];
                        var params2;
                        if (action.payload.merge) {
                            params2 = action.payload.params !== undefined || routeParamList[route1.name] !== undefined ? _object_spread._({}, routeParamList[route1.name], route1.params, action.payload.params) : route1.params;
                        } else {
                            params2 = routeParamList[route1.name] !== undefined ? _object_spread._({}, routeParamList[route1.name], action.payload.params) : action.payload.params;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            index: index1,
                            routes: _to_consumable_array._(state.routes.slice(0, index1)).concat([
                                params2 !== route1.params ? _object_spread_props._(_object_spread._({}, route1), {
                                    params: params2
                                }) : state.routes[index1]
                            ])
                        });
                    }
                case 'POP':
                    {
                        var index2 = action.target === state.key && action.source ? state.routes.findIndex((r)=>r.key === action.source) : state.index;
                        if (index2 > 0) {
                            var count = Math.max(index2 - action.payload.count + 1, 1);
                            var routes2 = state.routes.slice(0, count).concat(state.routes.slice(index2 + 1));
                            return _object_spread_props._(_object_spread._({}, state), {
                                index: routes2.length - 1,
                                routes: routes2
                            });
                        }
                        return null;
                    }
                case 'POP_TO_TOP':
                    return router.getStateForAction(state, {
                        type: 'POP',
                        payload: {
                            count: state.routes.length - 1
                        }
                    }, options);
                case 'POP_TO':
                    {
                        if (!state.routeNames.includes(action.payload.name)) {
                            return null;
                        }
                        // If the route already exists, navigate to that
                        var index3 = -1;
                        var getId2 = options.routeGetIdList[action.payload.name];
                        var id2 = getId2 === null || getId2 === void 0 ? void 0 : getId2({
                            params: action.payload.params
                        });
                        if (id2) {
                            index3 = state.routes.findIndex((route)=>route.name === action.payload.name && id2 === (getId2 === null || getId2 === void 0 ? void 0 : getId2({
                                    params: route.params
                                })));
                        } else if (state.routes[state.index].name === action.payload.name) {
                            index3 = state.index;
                        } else {
                            for(var i1 = state.routes.length - 1; i1 >= 0; i1--){
                                if (state.routes[i1].name === action.payload.name) {
                                    index3 = i1;
                                    break;
                                }
                            }
                        }
                        // If the route doesn't exist, remove the current route and add the new one
                        if (index3 === -1) {
                            var routes3 = _to_consumable_array._(state.routes.slice(0, -1)).concat([
                                {
                                    key: `${action.payload.name}-${(0, _nonsecure.nanoid)()}`,
                                    name: action.payload.name,
                                    params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                                }
                            ]);
                            return _object_spread_props._(_object_spread._({}, state), {
                                routes: routes3,
                                index: routes3.length - 1
                            });
                        }
                        var route2 = state.routes[index3];
                        var params3;
                        if (action.payload.merge) {
                            params3 = action.payload.params !== undefined || routeParamList[route2.name] !== undefined ? _object_spread._({}, routeParamList[route2.name], route2.params, action.payload.params) : route2.params;
                        } else {
                            params3 = routeParamList[route2.name] !== undefined ? _object_spread._({}, routeParamList[route2.name], action.payload.params) : action.payload.params;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            index: index3,
                            routes: _to_consumable_array._(state.routes.slice(0, index3)).concat([
                                params3 !== route2.params ? _object_spread_props._(_object_spread._({}, route2), {
                                    params: params3
                                }) : state.routes[index3]
                            ])
                        });
                    }
                case 'GO_BACK':
                    if (state.index > 0) {
                        return router.getStateForAction(state, {
                            type: 'POP',
                            payload: {
                                count: 1
                            },
                            target: action.target,
                            source: action.source
                        }, options);
                    }
                    return null;
                case 'PRELOAD':
                    {
                        var getId3 = options.routeGetIdList[action.payload.name];
                        var id3 = getId3 === null || getId3 === void 0 ? void 0 : getId3({
                            params: action.payload.params
                        });
                        var route3;
                        if (id3 !== undefined) {
                            route3 = state.routes.find((route)=>route.name === action.payload.name && id3 === (getId3 === null || getId3 === void 0 ? void 0 : getId3({
                                    params: route.params
                                })));
                        }
                        if (route3) {
                            return _object_spread_props._(_object_spread._({}, state), {
                                routes: state.routes.map((r)=>{
                                    if (r.key !== (route3 === null || route3 === void 0 ? void 0 : route3.key)) {
                                        return r;
                                    }
                                    return _object_spread_props._(_object_spread._({}, r), {
                                        params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                                    });
                                })
                            });
                        } else {
                            return _object_spread_props._(_object_spread._({}, state), {
                                preloadedRoutes: state.preloadedRoutes.filter((r)=>r.name !== action.payload.name || id3 !== (getId3 === null || getId3 === void 0 ? void 0 : getId3({
                                        params: r.params
                                    }))).concat({
                                    key: `${action.payload.name}-${(0, _nonsecure.nanoid)()}`,
                                    name: action.payload.name,
                                    params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                                })
                            });
                        }
                    }
                default:
                    return _BaseRouter.BaseRouter.getStateForAction(state, action);
            }
        },
        actionCreators: StackActions
    });
    return router;
} //# sourceMappingURL=StackRouter.js.map


}),
77730: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get TabActions () {
        return TabActions;
    },
    get TabRouter () {
        return TabRouter;
    }
});
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _to_consumable_array = __webpack_require__(92716);
var _nonsecure = __webpack_require__(57024);
var _BaseRouter = __webpack_require__(41252);
var TYPE_ROUTE = 'route';
var TabActions = {
    jumpTo (name, params) {
        return {
            type: 'JUMP_TO',
            payload: {
                name,
                params
            }
        };
    }
};
var getRouteHistory = (routes, index, backBehavior, initialRouteName)=>{
    var history = [
        {
            type: TYPE_ROUTE,
            key: routes[index].key
        }
    ];
    var initialRouteIndex;
    switch(backBehavior){
        case 'order':
            for(var i = index; i > 0; i--){
                history.unshift({
                    type: TYPE_ROUTE,
                    key: routes[i - 1].key
                });
            }
            break;
        case 'firstRoute':
            if (index !== 0) {
                history.unshift({
                    type: TYPE_ROUTE,
                    key: routes[0].key
                });
            }
            break;
        case 'initialRoute':
            initialRouteIndex = routes.findIndex((route)=>route.name === initialRouteName);
            initialRouteIndex = initialRouteIndex === -1 ? 0 : initialRouteIndex;
            if (index !== initialRouteIndex) {
                history.unshift({
                    type: TYPE_ROUTE,
                    key: routes[initialRouteIndex].key
                });
            }
            break;
        case 'history':
        case 'fullHistory':
            break;
    }
    return history;
};
var changeIndex = (state, index, backBehavior, initialRouteName)=>{
    var history = state.history;
    if (backBehavior === 'history' || backBehavior === 'fullHistory') {
        var currentRouteKey = state.routes[index].key;
        if (backBehavior === 'history') {
            // Remove the existing key from the history to de-duplicate it
            history = history.filter((it)=>it.type === 'route' ? it.key !== currentRouteKey : false);
        } else if (backBehavior === 'fullHistory') {
            var _history_lastHistoryRouteItemIndex;
            var lastHistoryRouteItemIndex = history.findLastIndex((item)=>item.type === 'route');
            if (currentRouteKey === ((_history_lastHistoryRouteItemIndex = history[lastHistoryRouteItemIndex]) === null || _history_lastHistoryRouteItemIndex === void 0 ? void 0 : _history_lastHistoryRouteItemIndex.key)) {
                // For full-history, only remove if it matches the last route
                // Useful for drawer, if current route was in history, then drawer state changed
                // Then we only need to move the route to the front
                history = _to_consumable_array._(history.slice(0, lastHistoryRouteItemIndex)).concat(_to_consumable_array._(history.slice(lastHistoryRouteItemIndex + 1)));
            }
        }
        history = history.concat({
            type: TYPE_ROUTE,
            key: currentRouteKey
        });
    } else {
        history = getRouteHistory(state.routes, index, backBehavior, initialRouteName);
    }
    return _object_spread_props._(_object_spread._({}, state), {
        index,
        history
    });
};
function TabRouter(ref) {
    var initialRouteName = ref.initialRouteName, _ref_backBehavior = ref.backBehavior, backBehavior = _ref_backBehavior === void 0 ? 'firstRoute' : _ref_backBehavior;
    var router = _object_spread_props._(_object_spread._({}, _BaseRouter.BaseRouter), {
        type: 'tab',
        getInitialState (ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var index = initialRouteName !== undefined && routeNames.includes(initialRouteName) ? routeNames.indexOf(initialRouteName) : 0;
            var routes = routeNames.map((name)=>({
                    name,
                    key: `${name}-${(0, _nonsecure.nanoid)()}`,
                    params: routeParamList[name]
                }));
            var history = getRouteHistory(routes, index, backBehavior, initialRouteName);
            return {
                stale: false,
                type: 'tab',
                key: `tab-${(0, _nonsecure.nanoid)()}`,
                index,
                routeNames,
                history,
                routes,
                preloadedRouteKeys: []
            };
        },
        getRehydratedState (partialState, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var _state_routes_, _state_history, _state_preloadedRouteKeys;
            var state = partialState;
            if (state.stale === false) {
                return state;
            }
            var routes = routeNames.map((name)=>{
                var route = state.routes.find((r)=>r.name === name);
                return _object_spread_props._(_object_spread._({}, route), {
                    name,
                    key: route && route.name === name && route.key ? route.key : `${name}-${(0, _nonsecure.nanoid)()}`,
                    params: routeParamList[name] !== undefined ? _object_spread._({}, routeParamList[name], route ? route.params : undefined) : route ? route.params : undefined
                });
            });
            var index = Math.min(Math.max(routeNames.indexOf((_state_routes_ = state.routes[(state === null || state === void 0 ? void 0 : state.index) ?? 0]) === null || _state_routes_ === void 0 ? void 0 : _state_routes_.name), 0), routes.length - 1);
            var routeKeys = routes.map((route)=>route.key);
            var history = ((_state_history = state.history) === null || _state_history === void 0 ? void 0 : _state_history.filter((it)=>routeKeys.includes(it.key))) ?? [];
            return changeIndex({
                stale: false,
                type: 'tab',
                key: `tab-${(0, _nonsecure.nanoid)()}`,
                index,
                routeNames,
                history,
                routes,
                preloadedRouteKeys: ((_state_preloadedRouteKeys = state.preloadedRouteKeys) === null || _state_preloadedRouteKeys === void 0 ? void 0 : _state_preloadedRouteKeys.filter((key)=>routeKeys.includes(key))) ?? []
            }, index, backBehavior, initialRouteName);
        },
        getStateForRouteNamesChange (state, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeKeyChanges = ref.routeKeyChanges;
            var routes = routeNames.map((name)=>state.routes.find((r)=>r.name === name && !routeKeyChanges.includes(r.name)) || {
                    name,
                    key: `${name}-${(0, _nonsecure.nanoid)()}`,
                    params: routeParamList[name]
                });
            var index = Math.max(0, routeNames.indexOf(state.routes[state.index].name));
            var history = state.history.filter(// Type will always be 'route' for tabs, but could be different in a router extending this (e.g. drawer)
            (it)=>it.type !== 'route' || routes.find((r)=>r.key === it.key));
            if (!history.length) {
                history = getRouteHistory(routes, index, backBehavior, initialRouteName);
            }
            return _object_spread_props._(_object_spread._({}, state), {
                history,
                routeNames,
                routes,
                index
            });
        },
        getStateForRouteFocus (state, key) {
            var index = state.routes.findIndex((r)=>r.key === key);
            if (index === -1 || index === state.index) {
                return state;
            }
            return changeIndex(state, index, backBehavior, initialRouteName);
        },
        getStateForAction (state, action, ref) {
            var routeParamList = ref.routeParamList, routeGetIdList = ref.routeGetIdList;
            switch(action.type){
                case 'JUMP_TO':
                case 'NAVIGATE':
                case 'NAVIGATE_DEPRECATED':
                    {
                        var index = state.routes.findIndex((route)=>route.name === action.payload.name);
                        if (index === -1) {
                            return null;
                        }
                        var updatedState = changeIndex(_object_spread_props._(_object_spread._({}, state), {
                            routes: state.routes.map((route)=>{
                                if (route.name !== action.payload.name) {
                                    return route;
                                }
                                var getId = routeGetIdList[route.name];
                                var currentId = getId === null || getId === void 0 ? void 0 : getId({
                                    params: route.params
                                });
                                var nextId = getId === null || getId === void 0 ? void 0 : getId({
                                    params: action.payload.params
                                });
                                var key = currentId === nextId ? route.key : `${route.name}-${(0, _nonsecure.nanoid)()}`;
                                var params;
                                if ((action.type === 'NAVIGATE' || action.type === 'NAVIGATE_DEPRECATED') && action.payload.merge && currentId === nextId) {
                                    params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], route.params, action.payload.params) : route.params;
                                } else {
                                    params = routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], action.payload.params) : action.payload.params;
                                }
                                var path = action.type === 'NAVIGATE' && action.payload.path != null ? action.payload.path : route.path;
                                return params !== route.params || path !== route.path ? _object_spread_props._(_object_spread._({}, route), {
                                    key,
                                    path,
                                    params
                                }) : route;
                            })
                        }), index, backBehavior, initialRouteName);
                        return _object_spread_props._(_object_spread._({}, updatedState), {
                            preloadedRouteKeys: updatedState.preloadedRouteKeys.filter((key)=>key !== state.routes[updatedState.index].key)
                        });
                    }
                case 'GO_BACK':
                    {
                        var _state_history_;
                        if (state.history.length === 1) {
                            return null;
                        }
                        var previousKey = (_state_history_ = state.history[state.history.length - 2]) === null || _state_history_ === void 0 ? void 0 : _state_history_.key;
                        var index1 = state.routes.findLastIndex((route)=>route.key === previousKey);
                        if (index1 === -1) {
                            return null;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            preloadedRouteKeys: state.preloadedRouteKeys.filter((key)=>key !== state.routes[index1].key),
                            history: state.history.slice(0, -1),
                            index: index1
                        });
                    }
                case 'PRELOAD':
                    {
                        var routeIndex = state.routes.findIndex((route)=>route.name === action.payload.name);
                        if (routeIndex === -1) {
                            return null;
                        }
                        var route = state.routes[routeIndex];
                        var getId = routeGetIdList[route.name];
                        var currentId = getId === null || getId === void 0 ? void 0 : getId({
                            params: route.params
                        });
                        var nextId = getId === null || getId === void 0 ? void 0 : getId({
                            params: action.payload.params
                        });
                        var key = currentId === nextId ? route.key : `${route.name}-${(0, _nonsecure.nanoid)()}`;
                        var params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], action.payload.params) : undefined;
                        var newRoute = params !== route.params ? _object_spread_props._(_object_spread._({}, route), {
                            key,
                            params
                        }) : route;
                        return _object_spread_props._(_object_spread._({}, state), {
                            preloadedRouteKeys: state.preloadedRouteKeys.filter((key)=>key !== route.key).concat(newRoute.key),
                            routes: state.routes.map((route, index)=>index === routeIndex ? newRoute : route),
                            history: key === route.key ? state.history : state.history.filter((record)=>record.key !== route.key)
                        });
                    }
                default:
                    return _BaseRouter.BaseRouter.getStateForAction(state, action);
            }
        },
        actionCreators: TabActions
    });
    return router;
} //# sourceMappingURL=TabRouter.js.map


}),
93675: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get BaseRouter () {
        return _BaseRouter.BaseRouter;
    },
    get CommonActions () {
        return _CommonActions;
    },
    get DrawerActions () {
        return _DrawerRouter.DrawerActions;
    },
    get DrawerRouter () {
        return _DrawerRouter.DrawerRouter;
    },
    get StackActions () {
        return _StackRouter.StackActions;
    },
    get StackRouter () {
        return _StackRouter.StackRouter;
    },
    get TabActions () {
        return _TabRouter.TabActions;
    },
    get TabRouter () {
        return _TabRouter.TabRouter;
    }
});
var _export_star = __webpack_require__(4084);
var _interop_require_wildcard = __webpack_require__(83610);
var _CommonActions = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(42208));
var _BaseRouter = __webpack_require__(41252);
var _DrawerRouter = __webpack_require__(11769);
var _StackRouter = __webpack_require__(26663);
var _TabRouter = __webpack_require__(77730);
_export_star._(__webpack_require__(1197), exports);
 //# sourceMappingURL=index.js.map


}),
1197: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
 //# sourceMappingURL=types.js.map


}),
57024: (function (__unused_webpack_module, exports) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get customAlphabet () {
        return customAlphabet;
    },
    get nanoid () {
        return nanoid;
    }
});
var urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
var customAlphabet = (alphabet, ref)=>{
    var defaultSize = ref === void 0 ? 21 : ref;
    return (ref)=>{
        var size = ref === void 0 ? defaultSize : ref;
        var id = '';
        var i = size | 0;
        while(i--){
            id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
    };
};
var nanoid = (ref)=>{
    var size = ref === void 0 ? 21 : ref;
    var id = '';
    var i = size | 0;
    while(i--){
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};


}),
86136: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _object_without_properties_loose = __webpack_require__(3574);
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose._(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
exports._ = _object_without_properties;


}),
3574: (function (__unused_webpack_module, exports) {
"use strict";

function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
exports._ = _object_without_properties_loose;


}),
71866: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _type_of = __webpack_require__(94210);
function _to_primitive(input, hint) {
    if (_type_of._(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_type_of._(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
exports._ = _to_primitive;


}),
46306: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _to_primitive = __webpack_require__(71866);
var _type_of = __webpack_require__(94210);
function _to_property_key(arg) {
    var key = _to_primitive._(arg, "string");
    return _type_of._(key) === "symbol" ? key : String(key);
}
exports._ = _to_property_key;


}),
63218: (function (module) {
"use strict";

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');
function decodeComponents(components, split) {
    try {
        // Try to decode the entire string first
        return [
            decodeURIComponent(components.join(''))
        ];
    } catch (err) {
    // Do nothing
    }
    if (components.length === 1) {
        return components;
    }
    split = split || 1;
    // Split the array in 2 parts
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
    try {
        return decodeURIComponent(input);
    } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for(var i = 1; i < tokens.length; i++){
            input = decodeComponents(tokens, i).join('');
            tokens = input.match(singleMatcher) || [];
        }
        return input;
    }
}
function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
        '%FE%FF': '\uFFFD\uFFFD',
        '%FF%FE': '\uFFFD\uFFFD'
    };
    var match = multiMatcher.exec(input);
    while(match){
        try {
            // Decode as big chunks as possible
            replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
            var result = decode(match[0]);
            if (result !== match[0]) {
                replaceMap[match[0]] = result;
            }
        }
        match = multiMatcher.exec(input);
    }
    // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    replaceMap['%C2'] = '\uFFFD';
    var entries = Object.keys(replaceMap);
    for(var i = 0; i < entries.length; i++){
        // Replace all decoded components
        var key = entries[i];
        input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }
    return input;
}
module.exports = function(encodedURI) {
    if (typeof encodedURI !== 'string') {
        throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }
    try {
        encodedURI = encodedURI.replace(/\+/g, ' ');
        // Try the built in decoder first
        return decodeURIComponent(encodedURI);
    } catch (err) {
        // Fallback to a more advanced decoder
        return customDecodeURIComponent(encodedURI);
    }
};


}),
48070: (function (module) {
"use strict";

module.exports = (string)=>{
    if (typeof string !== 'string') {
        throw new TypeError('Expected a string');
    }
    // Escape characters with special meaning either inside or outside character sets.
    // Use a simple backslash escape when its always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
    return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
};


}),
73991: (function (module) {
"use strict";

module.exports = function(obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
            ret[key] = val;
        }
    }
    return ret;
};


}),
26930: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(78474);
var _to_consumable_array = __webpack_require__(92716);
var strictUriEncode = __webpack_require__(99968);
var decodeComponent = __webpack_require__(63218);
var splitOnFirst = __webpack_require__(53058);
var filterObject = __webpack_require__(73991);
var isNullOrUndefined = (value)=>value === null || value === undefined;
var encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');
function encoderForArrayFormat(options) {
    switch(options.arrayFormat){
        case 'index':
            return (key)=>(result, value)=>{
                    var index = result.length;
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            [
                                encode(key, options),
                                '[',
                                index,
                                ']'
                            ].join('')
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            '[',
                            encode(index, options),
                            ']=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
        case 'bracket':
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            [
                                encode(key, options),
                                '[]'
                            ].join('')
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            '[]=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
        case 'colon-list-separator':
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            [
                                encode(key, options),
                                ':list='
                            ].join('')
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            ':list=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
        case 'comma':
        case 'separator':
        case 'bracket-separator':
            {
                var keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
                return (key)=>(result, value)=>{
                        if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                            return result;
                        }
                        // Translate null to an empty string so that it doesn't serialize as 'null'
                        value = value === null ? '' : value;
                        if (result.length === 0) {
                            return [
                                [
                                    encode(key, options),
                                    keyValueSep,
                                    encode(value, options)
                                ].join('')
                            ];
                        }
                        return [
                            [
                                result,
                                encode(value, options)
                            ].join(options.arrayFormatSeparator)
                        ];
                    };
            }
        default:
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            encode(key, options)
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            '=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
    }
}
function parserForArrayFormat(options) {
    var result;
    switch(options.arrayFormat){
        case 'index':
            return (key, value, accumulator)=>{
                result = /\[(\d*)\]$/.exec(key);
                key = key.replace(/\[\d*\]$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = {};
                }
                accumulator[key][result[1]] = value;
            };
        case 'bracket':
            return (key, value, accumulator)=>{
                result = /(\[\])$/.exec(key);
                key = key.replace(/\[\]$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = [
                        value
                    ];
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
        case 'colon-list-separator':
            return (key, value, accumulator)=>{
                result = /(:list)$/.exec(key);
                key = key.replace(/:list$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = [
                        value
                    ];
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
        case 'comma':
        case 'separator':
            return (key, value, accumulator)=>{
                var isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
                var isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
                value = isEncodedArray ? decode(value, options) : value;
                var newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item)=>decode(item, options)) : value === null ? value : decode(value, options);
                accumulator[key] = newValue;
            };
        case 'bracket-separator':
            return (key, value, accumulator)=>{
                var isArray = /(\[\])$/.test(key);
                key = key.replace(/\[\]$/, '');
                if (!isArray) {
                    accumulator[key] = value ? decode(value, options) : value;
                    return;
                }
                var arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item)=>decode(item, options));
                if (accumulator[key] === undefined) {
                    accumulator[key] = arrayValue;
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], arrayValue);
            };
        default:
            return (key, value, accumulator)=>{
                if (accumulator[key] === undefined) {
                    accumulator[key] = value;
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
    }
}
function validateArrayFormatSeparator(value) {
    if (typeof value !== 'string' || value.length !== 1) {
        throw new TypeError('arrayFormatSeparator must be single character string');
    }
}
function encode(value, options) {
    if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    }
    return value;
}
function decode(value, options) {
    if (options.decode) {
        return decodeComponent(value);
    }
    return value;
}
function keysSorter(input) {
    if (Array.isArray(input)) {
        return input.sort();
    }
    if (typeof input === 'object') {
        return keysSorter(Object.keys(input)).sort((a, b)=>Number(a) - Number(b)).map((key)=>input[key]);
    }
    return input;
}
function removeHash(input) {
    var hashStart = input.indexOf('#');
    if (hashStart !== -1) {
        input = input.slice(0, hashStart);
    }
    return input;
}
function getHash(url) {
    var hash = '';
    var hashStart = url.indexOf('#');
    if (hashStart !== -1) {
        hash = url.slice(hashStart);
    }
    return hash;
}
function extract(input) {
    input = removeHash(input);
    var queryStart = input.indexOf('?');
    if (queryStart === -1) {
        return '';
    }
    return input.slice(queryStart + 1);
}
function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
        value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
        value = value.toLowerCase() === 'true';
    }
    return value;
}
function parse(query, options) {
    options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ',',
        parseNumbers: false,
        parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    var formatter = parserForArrayFormat(options);
    // Create an object with no prototype
    var ret = Object.create(null);
    if (typeof query !== 'string') {
        return ret;
    }
    query = query.trim().replace(/^[?#&]/, '');
    if (!query) {
        return ret;
    }
    for (var param of query.split('&')){
        if (param === '') {
            continue;
        }
        var _splitOnFirst = _sliced_to_array._(splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '='), 2), key = _splitOnFirst[0], value = _splitOnFirst[1];
        // Missing `=` should be `null`:
        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
        value = value === undefined ? null : [
            'comma',
            'separator',
            'bracket-separator'
        ].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
    }
    for (var key1 of Object.keys(ret)){
        var value1 = ret[key1];
        if (typeof value1 === 'object' && value1 !== null) {
            for (var k of Object.keys(value1)){
                value1[k] = parseValue(value1[k], options);
            }
        } else {
            ret[key1] = parseValue(value1, options);
        }
    }
    if (options.sort === false) {
        return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key)=>{
        var value = ret[key];
        if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
            // Sort object keys, not values
            result[key] = keysSorter(value);
        } else {
            result[key] = value;
        }
        return result;
    }, Object.create(null));
}
exports.extract = extract;
exports.parse = parse;
exports.stringify = (object, options)=>{
    if (!object) {
        return '';
    }
    options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ','
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    var shouldFilter = (key)=>options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
    var formatter = encoderForArrayFormat(options);
    var objectCopy = {};
    for (var key of Object.keys(object)){
        if (!shouldFilter(key)) {
            objectCopy[key] = object[key];
        }
    }
    var keys = Object.keys(objectCopy);
    if (options.sort !== false) {
        keys.sort(options.sort);
    }
    return keys.map((key)=>{
        var value = object[key];
        if (value === undefined) {
            return '';
        }
        if (value === null) {
            return encode(key, options);
        }
        if (Array.isArray(value)) {
            if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
                return encode(key, options) + '[]';
            }
            return value.reduce(formatter(key), []).join('&');
        }
        return encode(key, options) + '=' + encode(value, options);
    }).filter((x)=>x.length > 0).join('&');
};
exports.parseUrl = (url, options)=>{
    options = Object.assign({
        decode: true
    }, options);
    var _splitOnFirst = _sliced_to_array._(splitOnFirst(url, '#'), 2), url_ = _splitOnFirst[0], hash = _splitOnFirst[1];
    return Object.assign({
        url: url_.split('?')[0] || '',
        query: parse(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash ? {
        fragmentIdentifier: decode(hash, options)
    } : {});
};
exports.stringifyUrl = (object, options)=>{
    options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
    }, options);
    var url = removeHash(object.url).split('?')[0] || '';
    var queryFromUrl = exports.extract(object.url);
    var parsedQueryFromUrl = exports.parse(queryFromUrl, {
        sort: false
    });
    var query = Object.assign(parsedQueryFromUrl, object.query);
    var queryString = exports.stringify(query, options);
    if (queryString) {
        queryString = `?${queryString}`;
    }
    var hash = getHash(object.url);
    if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString}${hash}`;
};
exports.pick = (input, filter, options)=>{
    options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
    }, options);
    var _exports_parseUrl = exports.parseUrl(input, options), url = _exports_parseUrl.url, query = _exports_parseUrl.query, fragmentIdentifier = _exports_parseUrl.fragmentIdentifier;
    return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
    }, options);
};
exports.exclude = (input, filter, options)=>{
    var exclusionFilter = Array.isArray(filter) ? (key)=>!filter.includes(key) : (key, value)=>!filter(key, value);
    return exports.pick(input, exclusionFilter, options);
};


}),
98722: (function (__unused_webpack_module, exports) {
"use strict";
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
Symbol.for("react.provider");
var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function typeOf(object) {
    if ("object" === typeof object && null !== object) {
        var $$typeof = object.$$typeof;
        switch($$typeof){
            case REACT_ELEMENT_TYPE:
                switch(object = object.type, object){
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                    case REACT_SUSPENSE_LIST_TYPE:
                    case REACT_VIEW_TRANSITION_TYPE:
                        return object;
                    default:
                        switch(object = object && object.$$typeof, object){
                            case REACT_CONTEXT_TYPE:
                            case REACT_FORWARD_REF_TYPE:
                            case REACT_LAZY_TYPE:
                            case REACT_MEMO_TYPE:
                                return object;
                            case REACT_CONSUMER_TYPE:
                                return object;
                            default:
                                return $$typeof;
                        }
                }
            case REACT_PORTAL_TYPE:
                return $$typeof;
        }
    }
}
exports.ContextConsumer = REACT_CONSUMER_TYPE;
exports.ContextProvider = REACT_CONTEXT_TYPE;
exports.Element = REACT_ELEMENT_TYPE;
exports.ForwardRef = REACT_FORWARD_REF_TYPE;
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.Lazy = REACT_LAZY_TYPE;
exports.Memo = REACT_MEMO_TYPE;
exports.Portal = REACT_PORTAL_TYPE;
exports.Profiler = REACT_PROFILER_TYPE;
exports.StrictMode = REACT_STRICT_MODE_TYPE;
exports.Suspense = REACT_SUSPENSE_TYPE;
exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
exports.isContextConsumer = function(object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
};
exports.isContextProvider = function(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
};
exports.isElement = function(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
};
exports.isForwardRef = function(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
};
exports.isFragment = function(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
};
exports.isLazy = function(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
};
exports.isMemo = function(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
};
exports.isPortal = function(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
};
exports.isProfiler = function(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
};
exports.isStrictMode = function(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
};
exports.isSuspense = function(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
};
exports.isSuspenseList = function(object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
};
exports.isValidElementType = function(type) {
    return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? !0 : !1;
};
exports.typeOf = typeOf;


}),
37899: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";

if (true) {
    module.exports = __webpack_require__(98722);
} else {}


}),
53058: (function (module) {
"use strict";

module.exports = (string, separator)=>{
    if (!(typeof string === 'string' && typeof separator === 'string')) {
        throw new TypeError('Expected the arguments to be of type `string`');
    }
    if (separator === '') {
        return [
            string
        ];
    }
    var separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
        return [
            string
        ];
    }
    return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
    ];
};


}),
99968: (function (module) {
"use strict";

module.exports = (str)=>encodeURIComponent(str).replace(/[!'()*]/g, (x)=>`%${x.charCodeAt(0).toString(16).toUpperCase()}`);


}),
694: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";

var React = __webpack_require__(31399);
/**
 * Use `useEffect` during SSR and `useLayoutEffect` in the Browser & React Native to avoid warnings.
 */ var useClientLayoutEffect = typeof document !== 'undefined' || typeof navigator !== 'undefined' && navigator.product === 'ReactNative' ? React.useLayoutEffect : React.useEffect;
/**
 * React hook which returns the latest callback without changing the reference.
 */ // eslint-disable-next-line @typescript-eslint/ban-types
function useLatestCallback(callback) {
    var ref = React.useRef(callback);
    var latestCallback = React.useRef(function latestCallback() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return ref.current.apply(this, args);
    }).current;
    useClientLayoutEffect(function() {
        ref.current = callback;
    });
    return latestCallback;
}
module.exports = useLatestCallback;


}),
70819: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var React = __webpack_require__(31399);
function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
}
var objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
        var inst = {
            hasValue: !1,
            value: null
        };
        instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(function() {
        function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
                hasMemo = !0;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
            }
            currentSelection = memoizedSelection;
            if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
            var nextSelection = selector(nextSnapshot);
            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
            memoizedSnapshot = nextSnapshot;
            return memoizedSelection = nextSelection;
        }
        var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
            function() {
                return memoizedSelector(getSnapshot());
            },
            null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
            }
        ];
    }, [
        getSnapshot,
        getServerSnapshot,
        selector,
        isEqual
    ]);
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(function() {
        inst.hasValue = !0;
        inst.value = value;
    }, [
        value
    ]);
    useDebugValue(value);
    return value;
};


}),
8352: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";

if (true) {
    module.exports = __webpack_require__(70819);
} else {}


}),

}]);//# sourceMappingURL=vendors-node_modules_react-navigation_native_lib_commonjs_index_js.chunk.bundle.map?platform=ios/* RCSSB */eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJoYXNoIjoiYWI1ZmUyMTQ0ODJmNjEzYTg0NjQxNmUzZjg2M2Y0NDJmNTJkODFjMjkxNWYxNDY1ZTExZDc1NTAwN2RkODk5MyIsImlhdCI6MTc1MDc2MDI4MX0.WYKm2OS_0J2-29Hhyl-3Dom3Wfq9SD8Ef2hAi5Yab4PFgvW_8y4gS2Hp_kVgRdtyXADYlKndfj08ltPjAM-ayJ79CnIEdQ86F2M3mFQZgCLLz0CJPQqECZiJzFsNKA5vDLihjAoDJKqxuwIdeApME7tfSGTJ5UVxcn5fJahp34jJo2cl9ZndCl5qDYwNNsXg5t7Qqn8ZPRgbZLtodmjg2IuL01BnQSqINK2yQE8n_TftL4Mew1XSplot4-3N9SFPYvJT3GGc4nukmQX1a5hJx516VZkVvU7vV_fYTDvtsYAq0JVCje_RZrffqe2Emv0fzVREYm_45TgqNN-VITo25w                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              