{"version":3,"file":"vendors-node_modules_react-native_Libraries_Components_View_ReactNativeStyleAttributes_js.chunk.bundle","sources":["webpack://miniApp/./node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js","webpack://miniApp/./node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.ios.js","webpack://miniApp/./node_modules/react-native/Libraries/StyleSheet/normalizeColor.js","webpack://miniApp/./node_modules/react-native/Libraries/StyleSheet/processAspectRatio.js","webpack://miniApp/./node_modules/react-native/Libraries/StyleSheet/processBackgroundImage.js","webpack://miniApp/./node_modules/react-native/Libraries/StyleSheet/processBoxShadow.js","webpack://miniApp/./node_modules/react-native/Libraries/StyleSheet/processColor.js","webpack://miniApp/./node_modules/react-native/Libraries/StyleSheet/processFilter.js","webpack://miniApp/./node_modules/react-native/Libraries/StyleSheet/processFontVariant.js","webpack://miniApp/./node_modules/react-native/Libraries/StyleSheet/processTransform.js","webpack://miniApp/./node_modules/react-native/Libraries/StyleSheet/processTransformOrigin.js","webpack://miniApp/./node_modules/react-native/Libraries/Utilities/differ/sizesDiffer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format strict-local\n *       strict-local\n */\n\n                                                                            \n\nimport processAspectRatio from '../../StyleSheet/processAspectRatio';\nimport processBackgroundImage from '../../StyleSheet/processBackgroundImage';\nimport processBoxShadow from '../../StyleSheet/processBoxShadow';\nimport processColor from '../../StyleSheet/processColor';\nimport processFilter from '../../StyleSheet/processFilter';\nimport processFontVariant from '../../StyleSheet/processFontVariant';\nimport processTransform from '../../StyleSheet/processTransform';\nimport processTransformOrigin from '../../StyleSheet/processTransformOrigin';\nimport sizesDiffer from '../../Utilities/differ/sizesDiffer';\n\nconst colorAttributes = {process: processColor};\n\nconst ReactNativeStyleAttributes                                    = {\n  /**\n   * Layout\n   */\n  alignContent: true,\n  alignItems: true,\n  alignSelf: true,\n  aspectRatio: {process: processAspectRatio},\n  borderBottomWidth: true,\n  borderEndWidth: true,\n  borderLeftWidth: true,\n  borderRightWidth: true,\n  borderStartWidth: true,\n  borderTopWidth: true,\n  boxSizing: true,\n  columnGap: true,\n  borderWidth: true,\n  bottom: true,\n  direction: true,\n  display: true,\n  end: true,\n  flex: true,\n  flexBasis: true,\n  flexDirection: true,\n  flexGrow: true,\n  flexShrink: true,\n  flexWrap: true,\n  gap: true,\n  height: true,\n  inset: true,\n  insetBlock: true,\n  insetBlockEnd: true,\n  insetBlockStart: true,\n  insetInline: true,\n  insetInlineEnd: true,\n  insetInlineStart: true,\n  justifyContent: true,\n  left: true,\n  margin: true,\n  marginBlock: true,\n  marginBlockEnd: true,\n  marginBlockStart: true,\n  marginBottom: true,\n  marginEnd: true,\n  marginHorizontal: true,\n  marginInline: true,\n  marginInlineEnd: true,\n  marginInlineStart: true,\n  marginLeft: true,\n  marginRight: true,\n  marginStart: true,\n  marginTop: true,\n  marginVertical: true,\n  maxHeight: true,\n  maxWidth: true,\n  minHeight: true,\n  minWidth: true,\n  overflow: true,\n  padding: true,\n  paddingBlock: true,\n  paddingBlockEnd: true,\n  paddingBlockStart: true,\n  paddingBottom: true,\n  paddingEnd: true,\n  paddingHorizontal: true,\n  paddingInline: true,\n  paddingInlineEnd: true,\n  paddingInlineStart: true,\n  paddingLeft: true,\n  paddingRight: true,\n  paddingStart: true,\n  paddingTop: true,\n  paddingVertical: true,\n  position: true,\n  right: true,\n  rowGap: true,\n  start: true,\n  top: true,\n  width: true,\n  zIndex: true,\n\n  /**\n   * Shadow\n   */\n  elevation: true,\n  shadowColor: colorAttributes,\n  shadowOffset: {diff: sizesDiffer},\n  shadowOpacity: true,\n  shadowRadius: true,\n\n  /**\n   * Transform\n   */\n  transform: {process: processTransform},\n  transformOrigin: {process: processTransformOrigin},\n\n  /**\n   * Filter\n   */\n  filter: {process: processFilter},\n\n  /**\n   * MixBlendMode\n   */\n  mixBlendMode: true,\n\n  /**\n   * Isolation\n   */\n  isolation: true,\n\n  /*\n   * BoxShadow\n   */\n  boxShadow: {process: processBoxShadow},\n\n  /**\n   * Linear Gradient\n   */\n  experimental_backgroundImage: {process: processBackgroundImage},\n\n  /**\n   * View\n   */\n  backfaceVisibility: true,\n  backgroundColor: colorAttributes,\n  borderBlockColor: colorAttributes,\n  borderBlockEndColor: colorAttributes,\n  borderBlockStartColor: colorAttributes,\n  borderBottomColor: colorAttributes,\n  borderBottomEndRadius: true,\n  borderBottomLeftRadius: true,\n  borderBottomRightRadius: true,\n  borderBottomStartRadius: true,\n  borderColor: colorAttributes,\n  borderCurve: true,\n  borderEndColor: colorAttributes,\n  borderEndEndRadius: true,\n  borderEndStartRadius: true,\n  borderLeftColor: colorAttributes,\n  borderRadius: true,\n  borderRightColor: colorAttributes,\n  borderStartColor: colorAttributes,\n  borderStartEndRadius: true,\n  borderStartStartRadius: true,\n  borderStyle: true,\n  borderTopColor: colorAttributes,\n  borderTopEndRadius: true,\n  borderTopLeftRadius: true,\n  borderTopRightRadius: true,\n  borderTopStartRadius: true,\n  cursor: true,\n  opacity: true,\n  outlineColor: colorAttributes,\n  outlineOffset: true,\n  outlineStyle: true,\n  outlineWidth: true,\n  pointerEvents: true,\n\n  /**\n   * Text\n   */\n  color: colorAttributes,\n  fontFamily: true,\n  fontSize: true,\n  fontStyle: true,\n  fontVariant: {process: processFontVariant},\n  fontWeight: true,\n  includeFontPadding: true,\n  letterSpacing: true,\n  lineHeight: true,\n  textAlign: true,\n  textAlignVertical: true,\n  textDecorationColor: colorAttributes,\n  textDecorationLine: true,\n  textDecorationStyle: true,\n  textShadowColor: colorAttributes,\n  textShadowOffset: true,\n  textShadowRadius: true,\n  textTransform: true,\n  userSelect: true,\n  verticalAlign: true,\n  writingDirection: true,\n\n  /**\n   * Image\n   */\n  overlayColor: colorAttributes,\n  resizeMode: true,\n  tintColor: colorAttributes,\n  objectFit: true,\n};\n\nmodule.exports = ReactNativeStyleAttributes;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *       strict-local\n */\n\n                                                        \n                                                               \n\n/** The actual type of the opaque NativeColorValue on iOS platform */\n                              \n                           \n             \n                                               \n                                              \n                                                            \n                                                           \n    \n  \n\nexport const PlatformColor = (...names               )             => {\n  // $FlowExpectedError[incompatible-return] LocalNativeColorValue is the iOS LocalNativeColorValue type\n  return ({semantic: names}                       );\n};\n\n                                           \n                    \n                   \n                                 \n                                \n  \n\nexport const DynamicColorIOSPrivate = (\n  tuple                             ,\n)             => {\n  return ({\n    dynamic: {\n      light: tuple.light,\n      dark: tuple.dark,\n      highContrastLight: tuple.highContrastLight,\n      highContrastDark: tuple.highContrastDark,\n    },\n    /* $FlowExpectedError[incompatible-return]\n     * LocalNativeColorValue is the actual type of the opaque NativeColorValue on iOS platform */\n  }                       );\n};\n\nconst _normalizeColorObject = (\n  color                       ,\n)                         => {\n  if ('semantic' in color) {\n    // an ios semantic color\n    return color;\n  } else if ('dynamic' in color && color.dynamic !== undefined) {\n    const normalizeColor = require('./normalizeColor');\n\n    // a dynamic, appearance aware color\n    const dynamic = color.dynamic;\n    const dynamicColor                        = {\n      dynamic: {\n        // $FlowFixMe[incompatible-use]\n        light: normalizeColor(dynamic.light),\n        // $FlowFixMe[incompatible-use]\n        dark: normalizeColor(dynamic.dark),\n        // $FlowFixMe[incompatible-use]\n        highContrastLight: normalizeColor(dynamic.highContrastLight),\n        // $FlowFixMe[incompatible-use]\n        highContrastDark: normalizeColor(dynamic.highContrastDark),\n      },\n    };\n    return dynamicColor;\n  }\n  return null;\n};\n\nexport const normalizeColorObject   \n                          \n                                          \n                                                                                               \n                          = _normalizeColorObject;\n\nconst _processColorObject = (\n  color                       ,\n)                         => {\n  if ('dynamic' in color && color.dynamic != null) {\n    const processColor = require('./processColor').default;\n    const dynamic = color.dynamic;\n    const dynamicColor                        = {\n      dynamic: {\n        // $FlowFixMe[incompatible-use]\n        light: processColor(dynamic.light),\n        // $FlowFixMe[incompatible-use]\n        dark: processColor(dynamic.dark),\n        // $FlowFixMe[incompatible-use]\n        highContrastLight: processColor(dynamic.highContrastLight),\n        // $FlowFixMe[incompatible-use]\n        highContrastDark: processColor(dynamic.highContrastDark),\n      },\n    };\n    return dynamicColor;\n  }\n  return color;\n};\n\nexport const processColorObject   \n                          \n                                          \n                                                                                               \n                       = _processColorObject;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *       strict-local\n */\n\n/* eslint no-bitwise: 0 */\n\n                                                        \n                                             \n\nimport _normalizeColor from '@react-native/normalize-colors';\n\nfunction normalizeColor(\n  color                                     ,\n)                       {\n  if (typeof color === 'object' && color != null) {\n    const {normalizeColorObject} = require('./PlatformColorValueTypes');\n    const normalizedColor = normalizeColorObject(color);\n    if (normalizedColor != null) {\n      return normalizedColor;\n    }\n  }\n\n  if (typeof color === 'string' || typeof color === 'number') {\n    return _normalizeColor(color);\n  }\n}\n\nmodule.exports = normalizeColor;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *       strict-local\n */\n\n'use strict';\n\nconst invariant = require('invariant');\n\nfunction processAspectRatio(aspectRatio                  )          {\n  if (typeof aspectRatio === 'number') {\n    return aspectRatio;\n  }\n  if (typeof aspectRatio !== 'string') {\n    if (__DEV__) {\n      invariant(\n        !aspectRatio,\n        'aspectRatio must either be a number, a ratio string or `auto`. You passed: %s',\n        aspectRatio,\n      );\n    }\n    return;\n  }\n\n  const matches = aspectRatio.split('/').map(s => s.trim());\n\n  if (matches.includes('auto')) {\n    if (__DEV__) {\n      invariant(\n        matches.length,\n        'aspectRatio does not support `auto <ratio>`. You passed: %s',\n        aspectRatio,\n      );\n    }\n    return;\n  }\n\n  const hasNonNumericValues = matches.some(n => Number.isNaN(Number(n)));\n  if (__DEV__) {\n    invariant(\n      !hasNonNumericValues && (matches.length === 1 || matches.length === 2),\n      'aspectRatio must either be a number, a ratio string or `auto`. You passed: %s',\n      aspectRatio,\n    );\n  }\n\n  if (hasNonNumericValues) {\n    return;\n  }\n\n  if (matches.length === 2) {\n    return Number(matches[0]) / Number(matches[1]);\n  }\n\n  return Number(matches[0]);\n}\n\nmodule.exports = processAspectRatio;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *       strict-local\n */\n\n'use strict';\n\n                                                        \n                                                     \n\nconst processColor = require('./processColor').default;\nconst DIRECTION_KEYWORD_REGEX =\n  /^to\\s+(?:top|bottom|left|right)(?:\\s+(?:top|bottom|left|right))?/i;\nconst ANGLE_UNIT_REGEX = /^([+-]?\\d*\\.?\\d+)(deg|grad|rad|turn)$/i;\n\n                              \n                                  \n                                     \n\n                            \n                         \n                                     \n                              \n                               \n                     \n     \n  \n\nconst DEFAULT_DIRECTION                          = {\n  type: 'angle',\n  value: 180,\n};\n\nexport default function processBackgroundImage(\n  backgroundImage                                           ,\n)                                      {\n  let result                                      = [];\n  if (backgroundImage == null) {\n    return result;\n  }\n\n  if (typeof backgroundImage === 'string') {\n    result = parseCSSLinearGradient(backgroundImage.replace(/\\n/g, ' '));\n  } else if (Array.isArray(backgroundImage)) {\n    for (const bgImage of backgroundImage) {\n      const processedColorStops         \n                                   \n                                \n         = [];\n      for (let index = 0; index < bgImage.colorStops.length; index++) {\n        const colorStop = bgImage.colorStops[index];\n        const processedColor = processColor(colorStop.color);\n        if (processedColor == null) {\n          // If a color is invalid, return an empty array and do not apply gradient. Same as web.\n          return [];\n        }\n        if (colorStop.positions != null && colorStop.positions.length > 0) {\n          for (const position of colorStop.positions) {\n            if (position.endsWith('%')) {\n              processedColorStops.push({\n                color: processedColor,\n                position: parseFloat(position) / 100,\n              });\n            } else {\n              // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n              return [];\n            }\n          }\n        } else {\n          processedColorStops.push({\n            color: processedColor,\n            position: null,\n          });\n        }\n      }\n\n      let direction                          = DEFAULT_DIRECTION;\n      const bgDirection =\n        bgImage.direction != null ? bgImage.direction.toLowerCase() : null;\n\n      if (bgDirection != null) {\n        if (ANGLE_UNIT_REGEX.test(bgDirection)) {\n          const parsedAngle = getAngleInDegrees(bgDirection);\n          if (parsedAngle != null) {\n            direction = {\n              type: 'angle',\n              value: parsedAngle,\n            };\n          } else {\n            // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n            return [];\n          }\n        } else if (DIRECTION_KEYWORD_REGEX.test(bgDirection)) {\n          const parsedDirection = getDirectionForKeyword(bgDirection);\n          if (parsedDirection != null) {\n            direction = parsedDirection;\n          } else {\n            // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n            return [];\n          }\n        } else {\n          // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      }\n\n      const fixedColorStops = getFixedColorStops(processedColorStops);\n\n      result = result.concat({\n        type: 'linearGradient',\n        direction,\n        colorStops: fixedColorStops,\n      });\n    }\n  }\n\n  return result;\n}\n\nfunction parseCSSLinearGradient(\n  cssString        ,\n)                                      {\n  const gradients = [];\n  let match;\n\n  // matches one or more linear-gradient functions in CSS\n  const linearGradientRegex = /linear-gradient\\s*\\(((?:\\([^)]*\\)|[^())])*)\\)/gi;\n\n  while ((match = linearGradientRegex.exec(cssString))) {\n    const gradientContent = match[1];\n    const parts = gradientContent.split(',');\n    let direction                          = DEFAULT_DIRECTION;\n    const trimmedDirection = parts[0].trim().toLowerCase();\n\n    // matches individual color stops in a gradient function\n    // supports various color formats: named colors, hex colors, rgb(a), and hsl(a)\n    // e.g. \"red 20%\", \"blue 50%\", \"rgba(0, 0, 0, 0.5) 30% 50%\"\n    // TODO: does not support color hint syntax yet. It is WIP.\n    const colorStopRegex =\n      /\\s*((?:(?:rgba?|hsla?)\\s*\\([^)]+\\))|#[0-9a-fA-F]+|[a-zA-Z]+)(?:\\s+(-?[0-9.]+%?)(?:\\s+(-?[0-9.]+%?))?)?\\s*/gi;\n\n    if (ANGLE_UNIT_REGEX.test(trimmedDirection)) {\n      const parsedAngle = getAngleInDegrees(trimmedDirection);\n      if (parsedAngle != null) {\n        direction = {\n          type: 'angle',\n          value: parsedAngle,\n        };\n        parts.shift();\n      } else {\n        // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n    } else if (DIRECTION_KEYWORD_REGEX.test(trimmedDirection)) {\n      const parsedDirection = getDirectionForKeyword(trimmedDirection);\n      if (parsedDirection != null) {\n        direction = parsedDirection;\n        parts.shift();\n      } else {\n        // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n    } else if (!colorStopRegex.test(trimmedDirection)) {\n      // If first part is not an angle/direction or a color stop, return an empty array and do not apply any gradient. Same as web.\n      return [];\n    }\n    colorStopRegex.lastIndex = 0;\n\n    const colorStops = [];\n    const fullColorStopsStr = parts.join(',');\n    let colorStopMatch;\n    while ((colorStopMatch = colorStopRegex.exec(fullColorStopsStr))) {\n      const [, color, position1, position2] = colorStopMatch;\n      const processedColor = processColor(color.trim().toLowerCase());\n      if (processedColor == null) {\n        // If a color is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n\n      if (typeof position1 !== 'undefined') {\n        if (position1.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position1) / 100,\n          });\n        } else {\n          // If a position is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      } else {\n        colorStops.push({\n          color: processedColor,\n          position: null,\n        });\n      }\n\n      if (typeof position2 !== 'undefined') {\n        if (position2.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position2) / 100,\n          });\n        } else {\n          // If a position is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      }\n    }\n\n    const fixedColorStops = getFixedColorStops(colorStops);\n\n    gradients.push({\n      type: 'linearGradient',\n      direction,\n      colorStops: fixedColorStops,\n    });\n  }\n\n  return gradients;\n}\n\nfunction getDirectionForKeyword(direction         )                           {\n  if (direction == null) {\n    return null;\n  }\n  // Remove extra whitespace\n  const normalized = direction.replace(/\\s+/g, ' ').toLowerCase();\n\n  switch (normalized) {\n    case 'to top':\n      return {type: 'angle', value: 0};\n    case 'to right':\n      return {type: 'angle', value: 90};\n    case 'to bottom':\n      return {type: 'angle', value: 180};\n    case 'to left':\n      return {type: 'angle', value: 270};\n    case 'to top right':\n    case 'to right top':\n      return {type: 'keyword', value: 'to top right'};\n    case 'to bottom right':\n    case 'to right bottom':\n      return {type: 'keyword', value: 'to bottom right'};\n    case 'to top left':\n    case 'to left top':\n      return {type: 'keyword', value: 'to top left'};\n    case 'to bottom left':\n    case 'to left bottom':\n      return {type: 'keyword', value: 'to bottom left'};\n    default:\n      return null;\n  }\n}\n\nfunction getAngleInDegrees(angle         )          {\n  if (angle == null) {\n    return null;\n  }\n  const match = angle.match(ANGLE_UNIT_REGEX);\n  if (!match) {\n    return null;\n  }\n\n  const [, value, unit] = match;\n\n  const numericValue = parseFloat(value);\n  switch (unit) {\n    case 'deg':\n      return numericValue;\n    case 'grad':\n      return numericValue * 0.9; // 1 grad = 0.9 degrees\n    case 'rad':\n      return (numericValue * 180) / Math.PI;\n    case 'turn':\n      return numericValue * 360; // 1 turn = 360 degrees\n    default:\n      return null;\n  }\n}\n\n// https://drafts.csswg.org/css-images-4/#color-stop-fixup\nfunction getFixedColorStops(\n  colorStops                  \n                               \n                            \n    ,\n)         \n                             \n                   \n   {\n  let fixedColorStops         \n                               \n                     \n     = [];\n  let hasNullPositions = false;\n  let maxPositionSoFar = colorStops[0].position ?? 0;\n  for (let i = 0; i < colorStops.length; i++) {\n    const colorStop = colorStops[i];\n    let newPosition = colorStop.position;\n    if (newPosition === null) {\n      // Step 1:\n      // If the first color stop does not have a position,\n      // set its position to 0%. If the last color stop does not have a position,\n      // set its position to 100%.\n      if (i === 0) {\n        newPosition = 0;\n      } else if (i === colorStops.length - 1) {\n        newPosition = 1;\n      }\n    }\n    // Step 2:\n    // If a color stop or transition hint has a position\n    // that is less than the specified position of any color stop or transition hint\n    // before it in the list, set its position to be equal to the\n    // largest specified position of any color stop or transition hint before it.\n    if (newPosition !== null) {\n      newPosition = Math.max(newPosition, maxPositionSoFar);\n      fixedColorStops[i] = {\n        color: colorStop.color,\n        position: newPosition,\n      };\n      maxPositionSoFar = newPosition;\n    } else {\n      hasNullPositions = true;\n    }\n  }\n\n  // Step 3:\n  // If any color stop still does not have a position,\n  // then, for each run of adjacent color stops without positions,\n  // set their positions so that they are evenly spaced between the preceding and\n  // following color stops with positions.\n  if (hasNullPositions) {\n    let lastDefinedIndex = 0;\n    for (let i = 1; i < fixedColorStops.length; i++) {\n      if (fixedColorStops[i] !== undefined) {\n        const unpositionedStops = i - lastDefinedIndex - 1;\n        if (unpositionedStops > 0) {\n          const startPosition = fixedColorStops[lastDefinedIndex].position;\n          const endPosition = fixedColorStops[i].position;\n          const increment =\n            (endPosition - startPosition) / (unpositionedStops + 1);\n          for (let j = 1; j <= unpositionedStops; j++) {\n            fixedColorStops[lastDefinedIndex + j] = {\n              color: colorStops[lastDefinedIndex + j].color,\n              position: startPosition + increment * j,\n            };\n          }\n        }\n        lastDefinedIndex = i;\n      }\n    }\n  }\n\n  return fixedColorStops;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *       strict-local\n * @format\n * @oncall react-native\n */\n\n                                                        \n                                                      \n\nimport processColor from './processColor';\n\n                               \n                  \n                  \n                              \n                      \n                          \n                  \n  \n\nexport default function processBoxShadow(\n  rawBoxShadows                                            ,\n)                         {\n  const result                         = [];\n  if (rawBoxShadows == null) {\n    return result;\n  }\n\n  const boxShadowList =\n    typeof rawBoxShadows === 'string'\n      ? parseBoxShadowString(rawBoxShadows.replace(/\\n/g, ' '))\n      : rawBoxShadows;\n\n  for (const rawBoxShadow of boxShadowList) {\n    const parsedBoxShadow                  = {\n      offsetX: 0,\n      offsetY: 0,\n    };\n\n    let value;\n    for (const arg in rawBoxShadow) {\n      switch (arg) {\n        case 'offsetX':\n          value =\n            typeof rawBoxShadow.offsetX === 'string'\n              ? parseLength(rawBoxShadow.offsetX)\n              : rawBoxShadow.offsetX;\n          if (value == null) {\n            return [];\n          }\n\n          parsedBoxShadow.offsetX = value;\n          break;\n        case 'offsetY':\n          value =\n            typeof rawBoxShadow.offsetY === 'string'\n              ? parseLength(rawBoxShadow.offsetY)\n              : rawBoxShadow.offsetY;\n          if (value == null) {\n            return [];\n          }\n\n          parsedBoxShadow.offsetY = value;\n          break;\n        case 'spreadDistance':\n          value =\n            typeof rawBoxShadow.spreadDistance === 'string'\n              ? parseLength(rawBoxShadow.spreadDistance)\n              : rawBoxShadow.spreadDistance;\n          if (value == null) {\n            return [];\n          }\n\n          parsedBoxShadow.spreadDistance = value;\n          break;\n        case 'blurRadius':\n          value =\n            typeof rawBoxShadow.blurRadius === 'string'\n              ? parseLength(rawBoxShadow.blurRadius)\n              : rawBoxShadow.blurRadius;\n          if (value == null || value < 0) {\n            return [];\n          }\n\n          parsedBoxShadow.blurRadius = value;\n          break;\n        case 'color':\n          const color = processColor(rawBoxShadow.color);\n          if (color == null) {\n            return [];\n          }\n\n          parsedBoxShadow.color = color;\n          break;\n        case 'inset':\n          parsedBoxShadow.inset = rawBoxShadow.inset;\n      }\n    }\n    result.push(parsedBoxShadow);\n  }\n  return result;\n}\n\nfunction parseBoxShadowString(rawBoxShadows        )                        {\n  let result                        = [];\n\n  for (const rawBoxShadow of rawBoxShadows\n    .split(/,(?![^()]*\\))/) // split by comma that is not in parenthesis\n    .map(bS => bS.trim())\n    .filter(bS => bS !== '')) {\n    const boxShadow                 = {\n      offsetX: 0,\n      offsetY: 0,\n    };\n    let offsetX                 ;\n    let offsetY                 ;\n    let keywordDetectedAfterLength = false;\n\n    let lengthCount = 0;\n\n    // split rawBoxShadow string by all whitespaces that are not in parenthesis\n    const args = rawBoxShadow.split(/\\s+(?![^(]*\\))/);\n    for (const arg of args) {\n      const processedColor = processColor(arg);\n      if (processedColor != null) {\n        if (boxShadow.color != null) {\n          return [];\n        }\n        if (offsetX != null) {\n          keywordDetectedAfterLength = true;\n        }\n        boxShadow.color = arg;\n        continue;\n      }\n\n      if (arg === 'inset') {\n        if (boxShadow.inset != null) {\n          return [];\n        }\n        if (offsetX != null) {\n          keywordDetectedAfterLength = true;\n        }\n        boxShadow.inset = true;\n        continue;\n      }\n\n      switch (lengthCount) {\n        case 0:\n          offsetX = arg;\n          lengthCount++;\n          break;\n        case 1:\n          if (keywordDetectedAfterLength) {\n            return [];\n          }\n          offsetY = arg;\n          lengthCount++;\n          break;\n        case 2:\n          if (keywordDetectedAfterLength) {\n            return [];\n          }\n          boxShadow.blurRadius = arg;\n          lengthCount++;\n          break;\n        case 3:\n          if (keywordDetectedAfterLength) {\n            return [];\n          }\n          boxShadow.spreadDistance = arg;\n          lengthCount++;\n          break;\n        default:\n          return [];\n      }\n    }\n\n    if (offsetX == null || offsetY == null) {\n      return [];\n    }\n\n    boxShadow.offsetX = offsetX;\n    boxShadow.offsetY = offsetY;\n\n    result.push(boxShadow);\n  }\n  return result;\n}\n\nfunction parseLength(length        )          {\n  // matches on args with units like \"1.5 5% -80deg\"\n  const argsWithUnitsRegex = /([+-]?\\d*(\\.\\d+)?)([\\w\\W]+)?/g;\n  const match = argsWithUnitsRegex.exec(length);\n\n  if (!match || Number.isNaN(match[1])) {\n    return null;\n  }\n\n  if (match[3] != null && match[3] !== 'px') {\n    return null;\n  }\n\n  return Number(match[1]);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *       strict-local\n */\n\n'use strict';\n\n                                                               \n\nconst Platform = require('../Utilities/Platform');\nconst normalizeColor = require('./normalizeColor');\n\n                                                            \n\n/* eslint no-bitwise: 0 */\nfunction processColor(color                         )                       {\n  if (color === undefined || color === null) {\n    return color;\n  }\n\n  let normalizedColor = normalizeColor(color);\n  if (normalizedColor === null || normalizedColor === undefined) {\n    return undefined;\n  }\n\n  if (typeof normalizedColor === 'object') {\n    const processColorObject =\n      require('./PlatformColorValueTypes').processColorObject;\n\n    const processedColorObj = processColorObject(normalizedColor);\n\n    if (processedColorObj != null) {\n      return processedColorObj;\n    }\n  }\n\n  if (typeof normalizedColor !== 'number') {\n    return null;\n  }\n\n  // Converts 0xrrggbbaa into 0xaarrggbb\n  normalizedColor = ((normalizedColor << 24) | (normalizedColor >>> 8)) >>> 0;\n\n  if (Platform.OS === 'android') {\n    // Android use 32 bit *signed* integer to represent the color\n    // We utilize the fact that bitwise operations in JS also operates on\n    // signed 32 bit integers, so that we can use those to convert from\n    // *unsigned* to *signed* 32bit int that way.\n    normalizedColor = normalizedColor | 0x0;\n  }\n  return normalizedColor;\n}\n\nexport default processColor;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format strict-local\n *      \n * @oncall react-native\n */\n\n'use strict';\n\n                                             \n                                                                       \n\nimport processColor from './processColor';\n\n                   \n                        \n                  \n                      \n                       \n                       \n                    \n                     \n                      \n                   \n                                   \n\n                         \n                  \n                  \n                             \n                     \n  \n\nexport default function processFilter(\n  filter                                            ,\n)                               {\n  let result                      = [];\n  if (filter == null) {\n    return result;\n  }\n\n  if (typeof filter === 'string') {\n    filter = filter.replace(/\\n/g, ' ');\n\n    // matches on functions with args and nested functions like \"drop-shadow(10 10 10 rgba(0, 0, 0, 1))\"\n    const regex = /([\\w-]+)\\(([^()]*|\\([^()]*\\)|[^()]*\\([^()]*\\)[^()]*)\\)/g;\n    let matches;\n\n    while ((matches = regex.exec(filter))) {\n      let filterName = matches[1].toLowerCase();\n      if (filterName === 'drop-shadow') {\n        const dropShadow = parseDropShadow(matches[2]);\n        if (dropShadow != null) {\n          result.push({dropShadow});\n        } else {\n          return [];\n        }\n      } else {\n        const camelizedName =\n          filterName === 'drop-shadow'\n            ? 'dropShadow'\n            : filterName === 'hue-rotate'\n              ? 'hueRotate'\n              : filterName;\n        const amount = _getFilterAmount(camelizedName, matches[2]);\n\n        if (amount != null) {\n          const filterFunction = {};\n          // $FlowFixMe The key will be the correct one but flow can't see that.\n          filterFunction[camelizedName] = amount;\n          // $FlowFixMe The key will be the correct one but flow can't see that.\n          result.push(filterFunction);\n        } else {\n          // If any primitive is invalid then apply none of the filters. This is how\n          // web works and makes it clear that something is wrong becuase no\n          // graphical effects are happening.\n          return [];\n        }\n      }\n    }\n  } else if (Array.isArray(filter)) {\n    for (const filterFunction of filter) {\n      const [filterName, filterValue] = Object.entries(filterFunction)[0];\n      if (filterName === 'dropShadow') {\n        // $FlowFixMe\n        const dropShadow = parseDropShadow(filterValue);\n        if (dropShadow == null) {\n          return [];\n        }\n        result.push({dropShadow});\n      } else {\n        const amount = _getFilterAmount(filterName, filterValue);\n\n        if (amount != null) {\n          const resultObject = {};\n          // $FlowFixMe\n          resultObject[filterName] = amount;\n          // $FlowFixMe\n          result.push(resultObject);\n        } else {\n          // If any primitive is invalid then apply none of the filters. This is how\n          // web works and makes it clear that something is wrong becuase no\n          // graphical effects are happening.\n          return [];\n        }\n      }\n    }\n  } else {\n    throw new TypeError(`${typeof filter} filter is not a string or array`);\n  }\n\n  return result;\n}\n\nfunction _getFilterAmount(filterName        , filterArgs       )          {\n  let filterArgAsNumber        ;\n  let unit        ;\n  if (typeof filterArgs === 'string') {\n    // matches on args with units like \"1.5 5% -80deg\"\n    const argsWithUnitsRegex = new RegExp(/([+-]?\\d*(\\.\\d+)?)([a-zA-Z%]+)?/g);\n    const match = argsWithUnitsRegex.exec(filterArgs);\n\n    if (!match || isNaN(Number(match[1]))) {\n      return undefined;\n    }\n\n    filterArgAsNumber = Number(match[1]);\n    unit = match[3];\n  } else if (typeof filterArgs === 'number') {\n    filterArgAsNumber = filterArgs;\n  } else {\n    return undefined;\n  }\n\n  switch (filterName) {\n    // Hue rotate takes some angle that can have a unit and can be\n    // negative. Additionally, 0 with no unit is allowed.\n    case 'hueRotate':\n      if (filterArgAsNumber === 0) {\n        return 0;\n      }\n      if (unit !== 'deg' && unit !== 'rad') {\n        return undefined;\n      }\n      return unit === 'rad'\n        ? (180 * filterArgAsNumber) / Math.PI\n        : filterArgAsNumber;\n    // blur takes any positive CSS length that is not a percent. In RN\n    // we currently only have DIPs, so we are not parsing units here.\n    case 'blur':\n      if ((unit && unit !== 'px') || filterArgAsNumber < 0) {\n        return undefined;\n      }\n      return filterArgAsNumber;\n    // All other filters except take a non negative number or percentage. There\n    // are no units associated with this value and percentage numbers map 1-to-1\n    // to a non-percentage number (e.g. 50% == 0.5).\n    case 'brightness':\n    case 'contrast':\n    case 'grayscale':\n    case 'invert':\n    case 'opacity':\n    case 'saturate':\n    case 'sepia':\n      if ((unit && unit !== '%' && unit !== 'px') || filterArgAsNumber < 0) {\n        return undefined;\n      }\n      if (unit === '%') {\n        filterArgAsNumber /= 100;\n      }\n      return filterArgAsNumber;\n    default:\n      return undefined;\n  }\n}\n\nfunction parseDropShadow(\n  rawDropShadow                          ,\n)                    {\n  const dropShadow =\n    typeof rawDropShadow === 'string'\n      ? parseDropShadowString(rawDropShadow)\n      : rawDropShadow;\n\n  const parsedDropShadow                   = {\n    offsetX: 0,\n    offsetY: 0,\n  };\n  let offsetX        ;\n  let offsetY        ;\n\n  for (const arg in dropShadow) {\n    let value;\n    switch (arg) {\n      case 'offsetX':\n        value =\n          typeof dropShadow.offsetX === 'string'\n            ? parseLength(dropShadow.offsetX)\n            : dropShadow.offsetX;\n        if (value == null) {\n          return null;\n        }\n        offsetX = value;\n        break;\n      case 'offsetY':\n        value =\n          typeof dropShadow.offsetY === 'string'\n            ? parseLength(dropShadow.offsetY)\n            : dropShadow.offsetY;\n        if (value == null) {\n          return null;\n        }\n        offsetY = value;\n        break;\n      case 'standardDeviation':\n        value =\n          typeof dropShadow.standardDeviation === 'string'\n            ? parseLength(dropShadow.standardDeviation)\n            : dropShadow.standardDeviation;\n        if (value == null || value < 0) {\n          return null;\n        }\n        parsedDropShadow.standardDeviation = value;\n        break;\n      case 'color':\n        const color = processColor(dropShadow.color);\n        if (color == null) {\n          return null;\n        }\n        parsedDropShadow.color = color;\n        break;\n      default:\n        return null;\n    }\n  }\n\n  if (offsetX == null || offsetY == null) {\n    return null;\n  }\n\n  parsedDropShadow.offsetX = offsetX;\n  parsedDropShadow.offsetY = offsetY;\n\n  return parsedDropShadow;\n}\n\nfunction parseDropShadowString(rawDropShadow        )                   {\n  const dropShadow                  = {\n    offsetX: 0,\n    offsetY: 0,\n  };\n  let offsetX        ;\n  let offsetY        ;\n  let lengthCount = 0;\n  let keywordDetectedAfterLength = false;\n\n  // split args by all whitespaces that are not in parenthesis\n  for (const arg of rawDropShadow.split(/\\s+(?![^(]*\\))/)) {\n    const processedColor = processColor(arg);\n    if (processedColor != null) {\n      if (dropShadow.color != null) {\n        return null;\n      }\n      if (offsetX != null) {\n        keywordDetectedAfterLength = true;\n      }\n      dropShadow.color = arg;\n      continue;\n    }\n\n    switch (lengthCount) {\n      case 0:\n        offsetX = arg;\n        lengthCount++;\n        break;\n      case 1:\n        if (keywordDetectedAfterLength) {\n          return null;\n        }\n        offsetY = arg;\n        lengthCount++;\n        break;\n      case 2:\n        if (keywordDetectedAfterLength) {\n          return null;\n        }\n        dropShadow.standardDeviation = arg;\n        lengthCount++;\n        break;\n      default:\n        return null;\n    }\n  }\n  if (offsetX == null || offsetY == null) {\n    return null;\n  }\n\n  dropShadow.offsetX = offsetX;\n  dropShadow.offsetY = offsetY;\n  return dropShadow;\n}\n\nfunction parseLength(length        )          {\n  // matches on args with units like \"1.5 5% -80deg\"\n  const argsWithUnitsRegex = /([+-]?\\d*(\\.\\d+)?)([\\w\\W]+)?/g;\n  const match = argsWithUnitsRegex.exec(length);\n\n  if (!match || Number.isNaN(match[1])) {\n    return null;\n  }\n\n  if (match[3] != null && match[3] !== 'px') {\n    return null;\n  }\n\n  return Number(match[1]);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *       strict-local\n */\n\n'use strict';\n\n                                                                     \n\nfunction processFontVariant(\n  fontVariant                                        ,\n)                                 {\n  if (Array.isArray(fontVariant)) {\n    return fontVariant;\n  }\n\n  // $FlowFixMe[incompatible-type]\n  const match                                 = fontVariant\n    .split(' ')\n    .filter(Boolean);\n\n  return match;\n}\n\nmodule.exports = processFontVariant;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *      \n */\n\n'use strict';\n\nconst stringifySafe = require('../Utilities/stringifySafe').default;\nconst invariant = require('invariant');\n\n/**\n * Generate a transform matrix based on the provided transforms, and use that\n * within the style object instead.\n *\n * This allows us to provide an API that is similar to CSS, where transforms may\n * be applied in an arbitrary order, and yet have a universal, singular\n * interface to native code.\n */\nfunction processTransform(\n  transform                        ,\n)                                {\n  if (typeof transform === 'string') {\n    const regex = new RegExp(/(\\w+)\\(([^)]+)\\)/g);\n    const transformArray                = [];\n    let matches;\n\n    while ((matches = regex.exec(transform))) {\n      const {key, value} = _getKeyAndValueFromCSSTransform(\n        matches[1],\n        matches[2],\n      );\n\n      if (value !== undefined) {\n        transformArray.push({[key]: value});\n      }\n    }\n    transform = transformArray;\n  }\n\n  if (__DEV__) {\n    _validateTransforms(transform);\n  }\n\n  return transform;\n}\n\nconst _getKeyAndValueFromCSSTransform   \n              \n               \n                                                                     = (\n  key,\n  args,\n) => {\n  const argsWithUnitsRegex = new RegExp(/([+-]?\\d+(\\.\\d+)?)([a-zA-Z]+|%)?/g);\n\n  switch (key) {\n    case 'matrix':\n      return {key, value: args.match(/[+-]?\\d+(\\.\\d+)?/g)?.map(Number)};\n    case 'translate':\n    case 'translate3d':\n      const parsedArgs = [];\n      let missingUnitOfMeasurement = false;\n\n      let matches;\n      while ((matches = argsWithUnitsRegex.exec(args))) {\n        const value = Number(matches[1]);\n        const unitOfMeasurement = matches[3];\n\n        if (value !== 0 && !unitOfMeasurement) {\n          missingUnitOfMeasurement = true;\n        }\n\n        if (unitOfMeasurement === '%') {\n          parsedArgs.push(`${value}%`);\n        } else {\n          parsedArgs.push(value);\n        }\n      }\n\n      if (__DEV__) {\n        invariant(\n          !missingUnitOfMeasurement,\n          `Transform with key ${key} must have units unless the provided value is 0, found %s`,\n          `${key}(${args})`,\n        );\n\n        if (key === 'translate') {\n          invariant(\n            parsedArgs?.length === 1 || parsedArgs?.length === 2,\n            'Transform with key translate must be an string with 1 or 2 parameters, found %s: %s',\n            parsedArgs?.length,\n            `${key}(${args})`,\n          );\n        } else {\n          invariant(\n            parsedArgs?.length === 3,\n            'Transform with key translate3d must be an string with 3 parameters, found %s: %s',\n            parsedArgs?.length,\n            `${key}(${args})`,\n          );\n        }\n      }\n\n      if (parsedArgs?.length === 1) {\n        parsedArgs.push(0);\n      }\n\n      return {key: 'translate', value: parsedArgs};\n    case 'translateX':\n    case 'translateY':\n    case 'perspective':\n      const argMatches = argsWithUnitsRegex.exec(args);\n\n      if (!argMatches?.length) {\n        return {key, value: undefined};\n      }\n\n      const value = Number(argMatches[1]);\n      const unitOfMeasurement = argMatches[3];\n\n      if (__DEV__) {\n        invariant(\n          value === 0 || unitOfMeasurement,\n          `Transform with key ${key} must have units unless the provided value is 0, found %s`,\n          `${key}(${args})`,\n        );\n      }\n\n      return {key, value};\n\n    default:\n      return {key, value: !isNaN(args) ? Number(args) : args};\n  }\n};\n\nfunction _validateTransforms(transform               )       {\n  transform.forEach(transformation => {\n    const keys = Object.keys(transformation);\n    invariant(\n      keys.length === 1,\n      'You must specify exactly one property per transform object. Passed properties: %s',\n      stringifySafe(transformation),\n    );\n    const key = keys[0];\n    const value = transformation[key];\n    if (key === 'matrix' && transform.length > 1) {\n      console.error(\n        'When using a matrix transform, you must specify exactly one transform object. Passed transform: ' +\n          stringifySafe(transform),\n      );\n    }\n    _validateTransform(key, value, transformation);\n  });\n}\n\nfunction _validateTransform(\n  key        ,\n  value                       ,\n  transformation     ,\n) {\n  invariant(\n    !value.getValue,\n    'You passed an Animated.Value to a normal component. ' +\n      'You need to wrap that component in an Animated. For example, ' +\n      'replace <View /> by <Animated.View />.',\n  );\n\n  const multivalueTransforms = ['matrix', 'translate'];\n  if (multivalueTransforms.indexOf(key) !== -1) {\n    invariant(\n      Array.isArray(value),\n      'Transform with key of %s must have an array as the value: %s',\n      key,\n      stringifySafe(transformation),\n    );\n  }\n  switch (key) {\n    case 'matrix':\n      invariant(\n        value.length === 9 || value.length === 16,\n        'Matrix transform must have a length of 9 (2d) or 16 (3d). ' +\n          'Provided matrix has a length of %s: %s',\n        /* $FlowFixMe[prop-missing] (>=0.84.0 site=react_native_fb) This\n         * comment suppresses an error found when Flow v0.84 was deployed. To\n         * see the error, delete this comment and run Flow. */\n        value.length,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'translate':\n      invariant(\n        value.length === 2 || value.length === 3,\n        'Transform with key translate must be an array of length 2 or 3, found %s: %s',\n        /* $FlowFixMe[prop-missing] (>=0.84.0 site=react_native_fb) This\n         * comment suppresses an error found when Flow v0.84 was deployed. To\n         * see the error, delete this comment and run Flow. */\n        value.length,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'rotateX':\n    case 'rotateY':\n    case 'rotateZ':\n    case 'rotate':\n    case 'skewX':\n    case 'skewY':\n      invariant(\n        typeof value === 'string',\n        'Transform with key of \"%s\" must be a string: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      invariant(\n        value.indexOf('deg') > -1 || value.indexOf('rad') > -1,\n        'Rotate transform must be expressed in degrees (deg) or radians ' +\n          '(rad): %s',\n        stringifySafe(transformation),\n      );\n      break;\n    case 'perspective':\n      invariant(\n        typeof value === 'number',\n        'Transform with key of \"%s\" must be a number: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      invariant(\n        value !== 0,\n        'Transform with key of \"%s\" cannot be zero: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'translateX':\n    case 'translateY':\n      invariant(\n        typeof value === 'number' ||\n          (typeof value === 'string' && value.endsWith('%')),\n        'Transform with key of \"%s\" must be number or a percentage. Passed value: %s.',\n        key,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'scale':\n    case 'scaleX':\n    case 'scaleY':\n      invariant(\n        typeof value === 'number',\n        'Transform with key of \"%s\" must be a number: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      break;\n    default:\n      invariant(\n        false,\n        'Invalid transform %s: %s',\n        key,\n        stringifySafe(transformation),\n      );\n  }\n}\n\nmodule.exports = processTransform;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *      \n */\n\nimport invariant from 'invariant';\n\nconst INDEX_X = 0;\nconst INDEX_Y = 1;\nconst INDEX_Z = 2;\n\n/* eslint-disable no-labels */\nexport default function processTransformOrigin(\n  transformOrigin                                 ,\n)                         {\n  if (typeof transformOrigin === 'string') {\n    const transformOriginString = transformOrigin;\n    const regex = /(top|bottom|left|right|center|\\d+(?:%|px)|0)/gi;\n    const transformOriginArray                         = ['50%', '50%', 0];\n\n    let index = INDEX_X;\n    let matches;\n    outer: while ((matches = regex.exec(transformOriginString))) {\n      let nextIndex = index + 1;\n\n      const value = matches[0];\n      const valueLower = value.toLowerCase();\n\n      switch (valueLower) {\n        case 'left':\n        case 'right': {\n          invariant(\n            index === INDEX_X,\n            'Transform-origin %s can only be used for x-position',\n            value,\n          );\n          transformOriginArray[INDEX_X] = valueLower === 'left' ? 0 : '100%';\n          break;\n        }\n        case 'top':\n        case 'bottom': {\n          invariant(\n            index !== INDEX_Z,\n            'Transform-origin %s can only be used for y-position',\n            value,\n          );\n          transformOriginArray[INDEX_Y] = valueLower === 'top' ? 0 : '100%';\n\n          // Handle [[ center | left | right ] && [ center | top | bottom ]] <length>?\n          if (index === INDEX_X) {\n            const horizontal = regex.exec(transformOriginString);\n            if (horizontal == null) {\n              break outer;\n            }\n\n            switch (horizontal[0].toLowerCase()) {\n              case 'left':\n                transformOriginArray[INDEX_X] = 0;\n                break;\n              case 'right':\n                transformOriginArray[INDEX_X] = '100%';\n                break;\n              case 'center':\n                transformOriginArray[INDEX_X] = '50%';\n                break;\n              default:\n                invariant(\n                  false,\n                  'Could not parse transform-origin: %s',\n                  transformOriginString,\n                );\n            }\n            nextIndex = INDEX_Z;\n          }\n\n          break;\n        }\n        case 'center': {\n          invariant(\n            index !== INDEX_Z,\n            'Transform-origin value %s cannot be used for z-position',\n            value,\n          );\n          transformOriginArray[index] = '50%';\n          break;\n        }\n        default: {\n          if (value.endsWith('%')) {\n            transformOriginArray[index] = value;\n          } else {\n            transformOriginArray[index] = parseFloat(value); // Remove `px`\n          }\n          break;\n        }\n      }\n\n      index = nextIndex;\n    }\n\n    transformOrigin = transformOriginArray;\n  }\n\n  if (__DEV__) {\n    _validateTransformOrigin(transformOrigin);\n  }\n\n  return transformOrigin;\n}\n\nfunction _validateTransformOrigin(transformOrigin                        ) {\n  invariant(\n    transformOrigin.length === 3,\n    'Transform origin must have exactly 3 values.',\n  );\n  const [x, y, z] = transformOrigin;\n  invariant(\n    typeof x === 'number' || (typeof x === 'string' && x.endsWith('%')),\n    'Transform origin x-position must be a number. Passed value: %s.',\n    x,\n  );\n  invariant(\n    typeof y === 'number' || (typeof y === 'string' && y.endsWith('%')),\n    'Transform origin y-position must be a number. Passed value: %s.',\n    y,\n  );\n  invariant(\n    typeof z === 'number',\n    'Transform origin z-position must be a number. Passed value: %s.',\n    z,\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *       strict\n * @format\n */\n\n'use strict';\n\nconst dummySize = {width: undefined, height: undefined};\n                                              \n\nconst sizesDiffer = function (one      , two      )          {\n  const defaultedOne = one || dummySize;\n  const defaultedTwo = two || dummySize;\n  return (\n    defaultedOne !== defaultedTwo &&\n    (defaultedOne.width !== defaultedTwo.width ||\n      defaultedOne.height !== defaultedTwo.height)\n  );\n};\n\nmodule.exports = sizesDiffer;\n"],"names":["colorAttributes","_processColor","ReactNativeStyleAttributes","_processAspectRatio","_sizesDiffer","_processTransform","_processTransformOrigin","_processFilter","_processBoxShadow","_processBackgroundImage","_processFontVariant","module","DynamicColorIOSPrivate","PlatformColor","normalizeColorObject","processColorObject","names","tuple","_normalizeColorObject","color","undefined","normalizeColor","require","dynamic","dynamicColor","_processColorObject","processColor","normalizedColor","_normalizecolors","invariant","processAspectRatio","aspectRatio","__DEV__","matches","s","hasNonNumericValues","n","Number","processBackgroundImage","DIRECTION_KEYWORD_REGEX","ANGLE_UNIT_REGEX","DEFAULT_DIRECTION","backgroundImage","result","parseCSSLinearGradient","Array","bgImage","processedColorStops","index","colorStop","processedColor","position","parseFloat","direction","bgDirection","parsedAngle","getAngleInDegrees","parsedDirection","getDirectionForKeyword","fixedColorStops","getFixedColorStops","cssString","gradients","match","linearGradientRegex","gradientContent","parts","trimmedDirection","colorStopRegex","colorStops","fullColorStopsStr","colorStopMatch","_colorStopMatch","position1","position2","normalized","angle","_match","value","unit","numericValue","Math","hasNullPositions","maxPositionSoFar","i","newPosition","lastDefinedIndex","i1","unpositionedStops","startPosition","endPosition","increment","j","processBoxShadow","rawBoxShadows","boxShadowList","parseBoxShadowString","rawBoxShadow","parsedBoxShadow","arg","parseLength","bS","boxShadow","offsetX","offsetY","keywordDetectedAfterLength","lengthCount","args","length","argsWithUnitsRegex","_default","Platform","processedColorObj","processFilter","filter","regex","filterName","dropShadow","parseDropShadow","camelizedName","amount","_getFilterAmount","filterFunction","filterFunction1","_Object_entries_","filterName1","filterValue","dropShadow1","amount1","resultObject","TypeError","filterArgs","filterArgAsNumber","RegExp","isNaN","rawDropShadow","parseDropShadowString","parsedDropShadow","processFontVariant","fontVariant","Boolean","stringifySafe","processTransform","transform","transformArray","_getKeyAndValueFromCSSTransform1","key","_validateTransforms","_getKeyAndValueFromCSSTransform","_args_match","parsedArgs","missingUnitOfMeasurement","unitOfMeasurement","argMatches","value1","unitOfMeasurement1","transformation","keys","Object","console","_validateTransform","multivalueTransforms","processTransformOrigin","INDEX_X","INDEX_Y","INDEX_Z","transformOrigin","transformOriginString","transformOriginArray","outer","nextIndex","valueLower","_invariant","horizontal","_validateTransformOrigin","_transformOrigin","x","y","z","dummySize","sizesDiffer","one","two","defaultedOne","defaultedTwo"],"mappings":"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"}